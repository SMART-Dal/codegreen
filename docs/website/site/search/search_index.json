{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CodeGreen","text":"<ul> <li> <p> Fast Energy Monitoring</p> <p>Real-time monitoring of CPU, GPU, and system energy consumption with minimal overhead.</p> <p> Getting Started</p> </li> <li> <p> Multi-Language Support</p> <p>Support for Python, C, C++, Java, and more with language-specific optimizations.</p> <p> Examples</p> </li> <li> <p> Advanced Analytics</p> <p>Detailed energy reports, visualizations, and optimization suggestions.</p> <p> CLI Reference</p> </li> <li> <p> Easy Integration</p> <p>CLI tools, Python API, and IDE plugins for seamless development workflow.</p> <p> Installation</p> </li> </ul>"},{"location":"#demo","title":"Demo","text":"<p>Watch CodeGreen in action: measuring energy consumption of a Python script.</p>"},{"location":"#what-is-codegreen","title":"What is CodeGreen?","text":"<p>CodeGreen is a comprehensive energy monitoring and optimization tool designed to help developers understand and reduce the energy consumption of their software. By providing real-time energy measurements, detailed analytics, and optimization suggestions, CodeGreen enables energy-aware software development.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>CodeGreen uses the Native Energy Measurement Backend (NEMB), a high-performance C++ measurement engine that:</p> <ul> <li>Signal-Generator Model: Lightweight timestamp markers (~100-200ns overhead) instead of synchronous hardware reads (~5-20\u03bcs)</li> <li>Background Polling: Independent C++ thread samples hardware sensors at configurable intervals (1-100ms)</li> <li>Time-Series Correlation: Binary search + linear interpolation matches checkpoints to energy readings</li> <li>Thread-Safe Invocation Tracking: Handles recursive functions and multi-threaded code with zero-lock performance</li> </ul> <p>This achieves 25-100x lower overhead than traditional profiling while maintaining \u00b12% accuracy.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd0b Energy Monitoring: Real-time monitoring of CPU, GPU, and system energy consumption</li> <li>\ud83d\udcca Code Analysis: Language-agnostic code analysis for energy optimization opportunities  </li> <li>\ud83d\udee0\ufe0f IDE Integration: Support for VSCode, IntelliJ, and other popular IDEs</li> <li>\ud83d\udd0c Hardware Plugins: Extensible plugin system for different hardware platforms</li> <li>\ud83d\udcc8 Visualization: Charts and reports for energy consumption analysis</li> <li>\u26a1 Code Instrumentation: Automatic code instrumentation for energy profiling</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started with CodeGreen in just a few steps:</p> InstallationInitializeMeasureAnalyze <pre><code>git clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\n./install.sh\n</code></pre> <pre><code>sudo codegreen init-sensors\n</code></pre> <pre><code>codegreen measure python my_script.py\n</code></pre> <pre><code>codegreen info\n</code></pre>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<ul> <li> <p> Linux</p> <p>Full support for Intel RAPL, NVIDIA NVML, and AMD hardware monitoring.</p> </li> <li> <p> macOS</p> <p>Support for Intel and Apple Silicon energy monitoring.</p> </li> <li> <p> Windows</p> <p>Windows-specific energy monitoring and optimization tools.</p> </li> </ul>"},{"location":"#community","title":"Community","text":"<p>Join our community to get help, share ideas, and contribute to CodeGreen:</p> <ul> <li> GitHub - Source code and issues</li> <li> Discussions - Community discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>CodeGreen is released under the MIT License. See the License page for details.</p>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to CodeGreen will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>Comprehensive website documentation</li> <li>CI/CD integration examples (GitHub Actions, GitLab CI, Jenkins)</li> <li>Language examples (Python, C/C++, Java)</li> <li>Energy measurement best practices guide</li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>Updated configuration structure to NEMB-based format</li> <li>Improved CLI reference with all commands documented</li> <li>Enhanced installation guide with troubleshooting</li> </ul>"},{"location":"about/changelog/#010-2026-01-06","title":"[0.1.0] - 2026-01-06","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>NEMB (Native Energy Measurement Backend)</li> <li>Signal-generator architecture for ultra-low overhead (~100-200ns per checkpoint)</li> <li>Background polling at configurable intervals (1-100ms)</li> <li>Multi-provider support (Intel RAPL, NVIDIA NVML, AMD ROCm)</li> <li>Thread-local invocation tracking for recursive functions</li> <li>Time-series correlation via binary search + linear interpolation</li> <li> <p>Atomic circular buffer for lock-free measurement storage</p> </li> <li> <p>Multi-Language Support</p> </li> <li>Python instrumentation via Tree-sitter</li> <li>C/C++ instrumentation via Tree-sitter</li> <li>Java instrumentation via Tree-sitter</li> <li> <p>Language-agnostic AST-based code analysis</p> </li> <li> <p>CLI Commands</p> </li> <li><code>measure</code>: Instrument and measure energy consumption</li> <li><code>analyze</code>: Static code analysis and instrumentation points</li> <li><code>init</code>: Interactive system initialization</li> <li><code>init-sensors</code>: Sensor permission setup</li> <li><code>info</code>: System and hardware information</li> <li><code>doctor</code>: Installation diagnostics</li> <li><code>benchmark</code>: Built-in synthetic workloads</li> <li><code>validate</code>: Accuracy validation against native tools</li> <li> <p><code>config</code>: Configuration management</p> </li> <li> <p>Hardware Sensor Support</p> </li> <li>Intel RAPL: Package, PP0 (cores), PP1 (iGPU), DRAM, PSYS</li> <li>NVIDIA NVML: GPU energy measurement</li> <li> <p>AMD ROCm SMI: AMD GPU monitoring</p> </li> <li> <p>Precision Modes</p> </li> <li>Low precision: 100ms polling, ~0.01% overhead, \u00b110% accuracy</li> <li>Medium precision: 10ms polling, ~0.1% overhead, \u00b15% accuracy (default)</li> <li> <p>High precision: 1ms polling, ~1% overhead, \u00b12% accuracy</p> </li> <li> <p>Output Formats</p> </li> <li>JSON format for machine-readable output</li> <li>Human-readable summary format</li> <li>CSV export for spreadsheet analysis</li> <li>Per-function energy attribution</li> <li> <p>Multi-sensor breakdown</p> </li> <li> <p>Configuration System</p> </li> <li>JSON-based configuration (<code>codegreen.json</code>)</li> <li>Hierarchical config search (project \u2192 user \u2192 system)</li> <li>NEMB coordinator settings</li> <li>Provider-specific configuration</li> <li>Instrumentation strategy options</li> </ul>"},{"location":"about/changelog/#performance","title":"Performance","text":"<ul> <li>25-100x lower overhead vs synchronous measurement</li> <li>&lt;1% total system overhead (high precision mode)</li> <li>\u00b12% measurement accuracy validated against Linux <code>perf</code></li> <li>Sub-millisecond checkpoint precision</li> </ul>"},{"location":"about/changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete user guide with examples</li> <li>API reference documentation</li> <li>Architecture and design documents</li> <li>CI/CD integration guide</li> <li>Contributing guidelines</li> </ul>"},{"location":"about/changelog/#validation","title":"Validation","text":"<ul> <li>Accuracy verified against Linux <code>perf</code> and external meters</li> <li>Long-running workloads: -3.88% delta (within \u00b12% target)</li> <li>Short-running workloads: -90% delta (filters runtime overhead by design)</li> <li>Cross-platform testing on Ubuntu, Fedora, Arch Linux</li> </ul>"},{"location":"about/changelog/#002-2025-12-15-legacy","title":"[0.0.2] - 2025-12-15 (Legacy)","text":""},{"location":"about/changelog/#added_2","title":"Added","text":"<ul> <li>Initial Python-based measurement system</li> <li>Basic RAPL sensor support</li> <li>Simple function-level instrumentation</li> <li>JSON output format</li> </ul>"},{"location":"about/changelog/#known-issues","title":"Known Issues","text":"<ul> <li>High measurement overhead (5-20\u03bcs per checkpoint)</li> <li>Synchronous I/O blocking</li> <li>Limited multi-threading support</li> <li>GIL contention in Python runtime</li> </ul>"},{"location":"about/changelog/#001-2025-11-01-legacy","title":"[0.0.1] - 2025-11-01 (Legacy)","text":""},{"location":"about/changelog/#added_3","title":"Added","text":"<ul> <li>Proof-of-concept energy measurement</li> <li>Intel RAPL file-based reading</li> <li>Basic command-line interface</li> <li>Manual checkpoint API</li> </ul>"},{"location":"about/changelog/#migration-guides","title":"Migration Guides","text":""},{"location":"about/changelog/#migrating-from-00x-to-010","title":"Migrating from 0.0.x to 0.1.0","text":"<p>Configuration File:</p> <p>Old (<code>config.json</code>): <pre><code>{\n  \"pmt\": {\n    \"preferred_sensors\": [\"rapl\", \"nvml\"],\n    \"measurement_interval_ms\": 1\n  }\n}\n</code></pre></p> <p>New (<code>codegreen.json</code>): <pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1\n      },\n      \"providers\": {\n        \"intel_rapl\": { \"enabled\": true },\n        \"nvidia_nvml\": { \"enabled\": true }\n      }\n    }\n  }\n}\n</code></pre></p> <p>Command Changes: <pre><code># Old\ncodegreen run python script.py\n\n# New\ncodegreen measure python script.py\n</code></pre></p> <p>Output Format: - <code>total_energy</code> \u2192 <code>total_energy_joules</code> - <code>execution_time</code> \u2192 <code>execution_time_ms</code> - Added <code>average_power_watts</code> - Added <code>sensors</code> breakdown</p>"},{"location":"about/changelog/#upcoming-features","title":"Upcoming Features","text":""},{"location":"about/changelog/#planned-for-020","title":"Planned for 0.2.0","text":"<ul> <li> Real-time energy monitoring dashboard</li> <li> GPU kernel-level profiling (CUDA, ROCm)</li> <li> ARM CPU support (energy probes)</li> <li> Windows support (ETW energy events)</li> <li> Energy budget enforcement</li> <li> Automated optimization suggestions</li> <li> IDE plugins (VS Code, IntelliJ)</li> </ul>"},{"location":"about/changelog/#under-consideration","title":"Under Consideration","text":"<ul> <li>Cloud deployment energy tracking</li> <li>Container-level energy attribution</li> <li>Machine learning model energy profiling</li> <li>Distributed system energy measurement</li> <li>Battery-powered device support</li> </ul>"},{"location":"about/changelog/#support-and-feedback","title":"Support and Feedback","text":"<ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: GitHub Discussions</li> <li>Documentation: docs.codegreen.io</li> </ul> <p>Note: Version numbers and dates are illustrative. Refer to GitHub releases for official version history.</p>"},{"location":"about/license/","title":"License","text":"<p>CodeGreen is released under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2024 CodeGreen Team\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>CodeGreen includes several third-party components:</p> <ul> <li>PMT (Power Measurement Toolkit): MIT License</li> <li>Tree-sitter: MIT License  </li> <li>Typer: MIT License</li> <li>Rich: MIT License</li> <li>Pydantic: MIT License</li> </ul>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to CodeGreen, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"api/config/","title":"Configuration API Reference","text":"<p>Programmatic configuration and settings management.</p>"},{"location":"api/config/#overview","title":"Overview","text":"<p>CodeGreen configuration can be managed through: - JSON configuration files - Environment variables - Command-line arguments - Programmatic API (advanced)</p>"},{"location":"api/config/#configuration-file-format","title":"Configuration File Format","text":""},{"location":"api/config/#complete-schema","title":"Complete Schema","text":"<pre><code>{\n  \"version\": \"0.1.0\",\n\n  \"measurement\": {\n    \"nemb\": {\n      \"enabled\": true,\n\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1,\n        \"measurement_buffer_size\": 100000,\n        \"auto_restart_failed_providers\": true,\n        \"provider_restart_interval\": 5000\n      },\n\n      \"timing\": {\n        \"precision\": \"high\",\n        \"clock_source\": \"auto\"\n      },\n\n      \"providers\": {\n        \"intel_rapl\": {\n          \"enabled\": true,\n          \"domains\": [\"package\", \"pp0\", \"dram\"],\n          \"validation_enabled\": true\n        },\n        \"nvidia_nvml\": {\n          \"enabled\": true,\n          \"device_indices\": [0],\n          \"validation_enabled\": true\n        },\n        \"amd_rocm\": {\n          \"enabled\": false\n        }\n      },\n\n      \"accuracy\": {\n        \"target_uncertainty_percent\": 1.0,\n        \"measurement_validation\": true,\n        \"outlier_detection\": true\n      }\n    }\n  },\n\n  \"instrumentation\": {\n    \"checkpoint_strategy\": \"functions\",\n    \"track_invocations\": true,\n    \"track_threads\": true,\n    \"language_specific\": {\n      \"python\": {\n        \"instrument_loops\": false,\n        \"max_recursion_depth\": 100\n      }\n    }\n  },\n\n  \"paths\": {\n    \"temp_directory\": {\n      \"base\": \"${SYSTEM_TEMP}\",\n      \"prefix\": \"codegreen_\",\n      \"cleanup_on_exit\": true\n    },\n    \"database\": {\n      \"default_path\": \"${USER_HOME}/.codegreen/energy_data.db\"\n    },\n    \"logs\": {\n      \"directory\": \"${USER_HOME}/.codegreen/logs\",\n      \"level\": \"INFO\",\n      \"max_files\": 10,\n      \"max_size_mb\": 50\n    }\n  },\n\n  \"output\": {\n    \"format\": \"json\",\n    \"verbose\": false\n  }\n}\n</code></pre>"},{"location":"api/config/#field-reference","title":"Field Reference","text":""},{"location":"api/config/#measurement-configuration","title":"Measurement Configuration","text":""},{"location":"api/config/#measurementnembenabled","title":"<code>measurement.nemb.enabled</code>","text":"<ul> <li>Type: boolean</li> <li>Default: <code>true</code></li> <li>Description: Enable NEMB measurement backend</li> </ul>"},{"location":"api/config/#measurementnembcoordinatormeasurement_interval_ms","title":"<code>measurement.nemb.coordinator.measurement_interval_ms</code>","text":"<ul> <li>Type: integer</li> <li>Range: 1-100</li> <li>Default: <code>1</code> (high precision)</li> <li>Description: Background polling interval in milliseconds</li> <li>Impact: Lower = more accurate, higher overhead</li> </ul>"},{"location":"api/config/#measurementnembcoordinatormeasurement_buffer_size","title":"<code>measurement.nemb.coordinator.measurement_buffer_size</code>","text":"<ul> <li>Type: integer</li> <li>Range: 1000-1000000</li> <li>Default: <code>100000</code></li> <li>Description: Circular buffer size for energy readings</li> <li>Memory: ~80 bytes per entry</li> </ul>"},{"location":"api/config/#measurementnembtimingprecision","title":"<code>measurement.nemb.timing.precision</code>","text":"<ul> <li>Type: enum</li> <li>Values: <code>\"low\"</code>, <code>\"medium\"</code>, <code>\"high\"</code></li> <li>Default: <code>\"high\"</code></li> <li>Description: Measurement precision level</li> <li>Presets:</li> <li><code>low</code>: 100ms interval, ~0.01% overhead, \u00b110% accuracy</li> <li><code>medium</code>: 10ms interval, ~0.1% overhead, \u00b15% accuracy</li> <li><code>high</code>: 1ms interval, ~1% overhead, \u00b12% accuracy</li> </ul>"},{"location":"api/config/#measurementnembtimingclock_source","title":"<code>measurement.nemb.timing.clock_source</code>","text":"<ul> <li>Type: enum</li> <li>Values: <code>\"auto\"</code>, <code>\"tsc\"</code>, <code>\"monotonic\"</code></li> <li>Default: <code>\"auto\"</code></li> <li>Description: High-resolution timer source</li> <li>Notes:</li> <li><code>tsc</code>: Time Stamp Counter (x86/x64 only, nanosecond precision)</li> <li><code>monotonic</code>: CLOCK_MONOTONIC (all platforms)</li> <li><code>auto</code>: Automatically selects best available</li> </ul>"},{"location":"api/config/#provider-configuration","title":"Provider Configuration","text":""},{"location":"api/config/#measurementnembprovidersintel_raplenabled","title":"<code>measurement.nemb.providers.intel_rapl.enabled</code>","text":"<ul> <li>Type: boolean</li> <li>Default: <code>true</code></li> <li>Description: Enable Intel RAPL sensor</li> </ul>"},{"location":"api/config/#measurementnembprovidersintel_rapldomains","title":"<code>measurement.nemb.providers.intel_rapl.domains</code>","text":"<ul> <li>Type: array of strings</li> <li>Default: <code>[\"package\", \"pp0\", \"dram\"]</code></li> <li>Values: <code>\"package\"</code>, <code>\"pp0\"</code>, <code>\"pp1\"</code>, <code>\"dram\"</code>, <code>\"psys\"</code></li> <li>Description: RAPL domains to measure</li> </ul>"},{"location":"api/config/#measurementnembprovidersnvidia_nvmlenabled","title":"<code>measurement.nemb.providers.nvidia_nvml.enabled</code>","text":"<ul> <li>Type: boolean</li> <li>Default: <code>true</code></li> <li>Description: Enable NVIDIA GPU measurement</li> </ul>"},{"location":"api/config/#measurementnembprovidersnvidia_nvmldevice_indices","title":"<code>measurement.nemb.providers.nvidia_nvml.device_indices</code>","text":"<ul> <li>Type: array of integers</li> <li>Default: <code>[0]</code></li> <li>Description: GPU device indices to monitor</li> </ul>"},{"location":"api/config/#instrumentation-configuration","title":"Instrumentation Configuration","text":""},{"location":"api/config/#instrumentationcheckpoint_strategy","title":"<code>instrumentation.checkpoint_strategy</code>","text":"<ul> <li>Type: enum</li> <li>Values: <code>\"minimal\"</code>, <code>\"functions\"</code>, <code>\"blocks\"</code>, <code>\"all\"</code></li> <li>Default: <code>\"functions\"</code></li> <li>Description: Checkpoint placement strategy</li> </ul>"},{"location":"api/config/#instrumentationtrack_invocations","title":"<code>instrumentation.track_invocations</code>","text":"<ul> <li>Type: boolean</li> <li>Default: <code>true</code></li> <li>Description: Track invocation count for recursive functions</li> </ul>"},{"location":"api/config/#instrumentationtrack_threads","title":"<code>instrumentation.track_threads</code>","text":"<ul> <li>Type: boolean</li> <li>Default: <code>true</code></li> <li>Description: Include thread ID in checkpoint names</li> </ul>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<p>Override configuration via environment variables:</p> Variable Config Path Example <code>CODEGREEN_PRECISION</code> <code>measurement.nemb.timing.precision</code> <code>high</code> <code>CODEGREEN_INTERVAL_MS</code> <code>measurement.nemb.coordinator.measurement_interval_ms</code> <code>1</code> <code>CODEGREEN_CONFIG</code> N/A (config file path) <code>/path/to/config.json</code> <code>CODEGREEN_LOG_LEVEL</code> <code>paths.logs.level</code> <code>DEBUG</code> <code>CODEGREEN_TEMP_DIR</code> <code>paths.temp_directory.base</code> <code>/tmp/codegreen</code> <p>Usage: <pre><code>export CODEGREEN_PRECISION=high\nexport CODEGREEN_LOG_LEVEL=DEBUG\ncodegreen measure python app.py\n</code></pre></p>"},{"location":"api/config/#command-line-overrides","title":"Command-Line Overrides","text":"<p>Override configuration via CLI arguments:</p> <pre><code>codegreen measure python app.py \\\n    --precision high \\\n    --sensors rapl nvidia \\\n    --output results.json \\\n    --config /path/to/custom_config.json\n</code></pre> <p>Priority: CLI args &gt; Environment vars &gt; Config file &gt; Defaults</p>"},{"location":"api/config/#programmatic-configuration-c","title":"Programmatic Configuration (C++)","text":""},{"location":"api/config/#load-configuration","title":"Load Configuration","text":"<pre><code>#include &lt;codegreen/config_loader.hpp&gt;\n\ncodegreen::ConfigLoader config(\"config.json\");\n\n// Access values\nint interval = config.get_int(\"measurement.nemb.coordinator.measurement_interval_ms\");\nstd::string precision = config.get_string(\"measurement.nemb.timing.precision\");\nbool rapl_enabled = config.get_bool(\"measurement.nemb.providers.intel_rapl.enabled\");\n</code></pre>"},{"location":"api/config/#modify-configuration","title":"Modify Configuration","text":"<pre><code>codegreen::ConfigLoader config;\n\nconfig.set(\"measurement.nemb.timing.precision\", \"high\");\nconfig.set(\"measurement.nemb.coordinator.measurement_interval_ms\", 1);\n\nconfig.save(\"updated_config.json\");\n</code></pre>"},{"location":"api/config/#programmatic-configuration-python","title":"Programmatic Configuration (Python)","text":""},{"location":"api/config/#load-configuration_1","title":"Load Configuration","text":"<pre><code>import json\n\nwith open('config.json') as f:\n    config = json.load(f)\n\nprecision = config['measurement']['nemb']['timing']['precision']\ninterval = config['measurement']['nemb']['coordinator']['measurement_interval_ms']\n</code></pre>"},{"location":"api/config/#modify-configuration_1","title":"Modify Configuration","text":"<pre><code>import json\n\nwith open('config.json') as f:\n    config = json.load(f)\n\nconfig['measurement']['nemb']['timing']['precision'] = 'high'\nconfig['measurement']['nemb']['coordinator']['measurement_interval_ms'] = 1\n\nwith open('config.json', 'w') as f:\n    json.dump(config, f, indent=2)\n</code></pre>"},{"location":"api/config/#configuration-management-commands","title":"Configuration Management Commands","text":""},{"location":"api/config/#view-current-configuration","title":"View Current Configuration","text":"<pre><code>codegreen config --show\n</code></pre>"},{"location":"api/config/#validate-configuration","title":"Validate Configuration","text":"<pre><code>codegreen config --validate\n</code></pre>"},{"location":"api/config/#edit-configuration","title":"Edit Configuration","text":"<pre><code>codegreen config --edit\n</code></pre> <p>Opens configuration in default editor (respects <code>$EDITOR</code>).</p>"},{"location":"api/config/#reset-to-defaults","title":"Reset to Defaults","text":"<pre><code>codegreen config --reset\n</code></pre>"},{"location":"api/config/#configuration-file-locations","title":"Configuration File Locations","text":"<p>CodeGreen searches for configuration in this order (first found is used):</p> <ol> <li>Specified via CLI: <code>--config /path/to/config.json</code></li> <li>Environment variable: <code>$CODEGREEN_CONFIG</code></li> <li>Current directory: <code>./codegreen.json</code></li> <li>User configuration: <code>~/.config/codegreen/codegreen.json</code></li> <li>System-wide: <code>/etc/codegreen/codegreen.json</code></li> </ol>"},{"location":"api/config/#check-active-configuration","title":"Check Active Configuration","text":"<pre><code>codegreen info --verbose\n</code></pre> <p>Shows which configuration file is being used.</p>"},{"location":"api/config/#best-practices","title":"Best Practices","text":""},{"location":"api/config/#1-project-specific-configuration","title":"1. Project-Specific Configuration","text":"<p>Commit project config to version control:</p> <pre><code># Create project config\ncp ~/.config/codegreen/codegreen.json ./codegreen.json\n\n# Customize for project\nvim codegreen.json\n\n# Commit\ngit add codegreen.json\ngit commit -m \"Add CodeGreen configuration\"\n</code></pre>"},{"location":"api/config/#2-user-wide-defaults","title":"2. User-Wide Defaults","text":"<p>Set personal defaults:</p> <pre><code>mkdir -p ~/.config/codegreen\ncp /usr/share/codegreen/codegreen.json ~/.config/codegreen/\nvim ~/.config/codegreen/codegreen.json\n</code></pre>"},{"location":"api/config/#3-cicd-configuration","title":"3. CI/CD Configuration","text":"<p>Use environment variables in CI:</p> <pre><code># .github/workflows/energy.yml\nenv:\n  CODEGREEN_PRECISION: high\n  CODEGREEN_INTERVAL_MS: 1\n\nsteps:\n  - run: codegreen measure python app.py\n</code></pre>"},{"location":"api/config/#4-validation-in-tests","title":"4. Validation in Tests","text":"<p>Validate configuration in test suite:</p> <pre><code># test_config.py\nimport json\nimport pytest\n\ndef test_config_valid():\n    with open('codegreen.json') as f:\n        config = json.load(f)\n\n    assert config['version'] == '0.1.0'\n    assert config['measurement']['nemb']['enabled'] is True\n    assert 1 &lt;= config['measurement']['nemb']['coordinator']['measurement_interval_ms'] &lt;= 100\n</code></pre>"},{"location":"api/config/#troubleshooting","title":"Troubleshooting","text":""},{"location":"api/config/#configuration-not-loading","title":"Configuration Not Loading","text":"<p>Check search path: <pre><code>codegreen info --verbose\n# Shows: \"Configuration loaded from: /path/to/config.json\"\n</code></pre></p>"},{"location":"api/config/#syntax-errors","title":"Syntax Errors","text":"<p>Validate JSON: <pre><code>python3 -m json.tool codegreen.json\n# OR\ncodegreen config --validate\n</code></pre></p>"},{"location":"api/config/#permission-issues","title":"Permission Issues","text":"<p>RAPL access: <pre><code>sudo codegreen init-sensors\n</code></pre></p>"},{"location":"api/config/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Complete configuration reference</li> <li>CLI Reference - Command-line options</li> <li>Installation - Setup guide</li> </ul>"},{"location":"api/core/","title":"Core API Reference","text":"<p>NEMB (Native Energy Measurement Backend) C++ API for advanced users and language runtime developers.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<p>The NEMB core API provides low-level access to energy measurement functionality. Most users should use the CLI (<code>codegreen measure</code>) instead. This API is for:</p> <ul> <li>Creating custom language runtimes</li> <li>Embedding energy measurement in applications</li> <li>Building profiling tools</li> <li>Direct hardware sensor access</li> </ul>"},{"location":"api/core/#public-api","title":"Public API","text":""},{"location":"api/core/#header-file","title":"Header File","text":"<pre><code>#include &lt;codegreen_energy.hpp&gt;\n</code></pre>"},{"location":"api/core/#initialization","title":"Initialization","text":"<p>Initialize NEMB measurement system:</p> <pre><code>bool nemb_initialize();\n</code></pre> <p>Returns: <code>true</code> on success, <code>false</code> if sensors unavailable</p> <p>Example: <pre><code>#include &lt;codegreen_energy.hpp&gt;\n\nint main() {\n    if (!nemb_initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize NEMB\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    // Ready to measure\n    return 0;\n}\n</code></pre></p>"},{"location":"api/core/#checkpoint-marking","title":"Checkpoint Marking","text":"<p>Mark execution checkpoint:</p> <pre><code>void nemb_mark_checkpoint(const char* name);\n</code></pre> <p>Parameters: - <code>name</code>: Checkpoint identifier (function name, label)</p> <p>Performance: ~100-200ns overhead</p> <p>Thread-safe: Yes (thread-local storage)</p> <p>Example: <pre><code>void process_data(const std::vector&lt;int&gt;&amp; data) {\n    nemb_mark_checkpoint(\"process_data_entry\");\n\n    // Function logic here\n    int sum = 0;\n    for (int x : data) {\n        sum += x;\n    }\n\n    nemb_mark_checkpoint(\"process_data_exit\");\n}\n</code></pre></p>"},{"location":"api/core/#energy-reading","title":"Energy Reading","text":"<p>Read current cumulative energy:</p> <pre><code>double nemb_read_current();\n</code></pre> <p>Returns: Cumulative energy in joules since initialization</p> <p>Note: Prefer checkpoint-based measurement for accuracy</p> <p>Example: <pre><code>double energy_before = nemb_read_current();\n\n// Run workload\ncompute_intensive_function();\n\ndouble energy_after = nemb_read_current();\ndouble energy_consumed = energy_after - energy_before;\n\nstd::cout &lt;&lt; \"Energy consumed: \" &lt;&lt; energy_consumed &lt;&lt; \" J\" &lt;&lt; std::endl;\n</code></pre></p>"},{"location":"api/core/#reporting","title":"Reporting","text":"<p>Generate energy report at program exit:</p> <pre><code>void nemb_report_at_exit(const char* output_file);\n</code></pre> <p>Parameters: - <code>output_file</code>: Path to JSON output file, or <code>nullptr</code> for stdout</p> <p>Automatically called at program exit if registered</p> <p>Example: <pre><code>int main() {\n    nemb_initialize();\n    nemb_report_at_exit(\"energy_report.json\");\n\n    // Program logic with checkpoints\n    nemb_mark_checkpoint(\"main_start\");\n    run_application();\n    nemb_mark_checkpoint(\"main_end\");\n\n    return 0;\n}\n// Report generated automatically at exit\n</code></pre></p>"},{"location":"api/core/#language-runtime-api","title":"Language Runtime API","text":"<p>For implementing language-specific wrappers:</p>"},{"location":"api/core/#python-runtime","title":"Python Runtime","text":"<pre><code>// codegreen_runtime.py (Cython wrapper)\ncdef extern from \"codegreen_energy.hpp\":\n    bint nemb_initialize()\n    void nemb_mark_checkpoint(const char* name)\n    double nemb_read_current()\n    void nemb_report_at_exit(const char* output_file)\n\ndef checkpoint(name: str):\n    nemb_mark_checkpoint(name.encode('utf-8'))\n\ndef initialize():\n    return nemb_initialize()\n\ndef get_current_energy():\n    return nemb_read_current()\n</code></pre>"},{"location":"api/core/#c-runtime","title":"C Runtime","text":"<pre><code>// codegreen_runtime.h\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint nemb_initialize(void);\nvoid nemb_mark_checkpoint(const char* name);\ndouble nemb_read_current(void);\nvoid nemb_report_at_exit(const char* output_file);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"api/core/#java-jni","title":"Java JNI","text":"<pre><code>// CodeGreenRuntime.java\npublic class CodeGreenRuntime {\n    static {\n        System.loadLibrary(\"codegreen-nemb\");\n    }\n\n    public static native boolean initialize();\n    public static native void markCheckpoint(String name);\n    public static native double readCurrent();\n    public static native void reportAtExit(String outputFile);\n\n    public static void checkpoint(String name) {\n        markCheckpoint(name);\n    }\n}\n</code></pre>"},{"location":"api/core/#macro-api-cc","title":"Macro API (C/C++)","text":"<p>Convenience macros for instrumentation:</p> <pre><code>#define CODEGREEN_CHECKPOINT(name) nemb_mark_checkpoint(name)\n#define CODEGREEN_FUNCTION_ENTRY() CODEGREEN_CHECKPOINT(__FUNCTION__ \"_entry\")\n#define CODEGREEN_FUNCTION_EXIT() CODEGREEN_CHECKPOINT(__FUNCTION__ \"_exit\")\n</code></pre> <p>Usage: <pre><code>void my_function() {\n    CODEGREEN_FUNCTION_ENTRY();\n\n    // Function body\n\n    CODEGREEN_FUNCTION_EXIT();\n}\n</code></pre></p>"},{"location":"api/core/#compilation","title":"Compilation","text":""},{"location":"api/core/#linking","title":"Linking","text":"<p>Link against the NEMB library:</p> <pre><code>g++ -o program program.cpp -lcodegreen-nemb -pthread\n</code></pre>"},{"location":"api/core/#cmake-integration","title":"CMake Integration","text":"<pre><code>find_library(CODEGREEN_NEMB codegreen-nemb REQUIRED)\n\nadd_executable(myapp main.cpp)\ntarget_link_libraries(myapp ${CODEGREEN_NEMB} pthread)\n</code></pre>"},{"location":"api/core/#examples","title":"Examples","text":""},{"location":"api/core/#minimal-example","title":"Minimal Example","text":"<pre><code>// minimal.cpp\n#include &lt;iostream&gt;\n#include &lt;codegreen_energy.hpp&gt;\n\nvoid compute() {\n    nemb_mark_checkpoint(\"compute_entry\");\n\n    int sum = 0;\n    for (int i = 0; i &lt; 1000000; i++) {\n        sum += i;\n    }\n\n    nemb_mark_checkpoint(\"compute_exit\");\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n}\n\nint main() {\n    if (!nemb_initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize NEMB\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    nemb_report_at_exit(\"energy.json\");\n\n    nemb_mark_checkpoint(\"main_start\");\n    compute();\n    nemb_mark_checkpoint(\"main_end\");\n\n    return 0;\n}\n</code></pre> <p>Compile and run: <pre><code>g++ -o minimal minimal.cpp -lcodegreen-nemb -pthread\n./minimal\ncat energy.json\n</code></pre></p>"},{"location":"api/core/#multi-threaded-example","title":"Multi-threaded Example","text":"<pre><code>// threaded.cpp\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;codegreen_energy.hpp&gt;\n\nvoid worker(int thread_id) {\n    char checkpoint_name[64];\n    snprintf(checkpoint_name, sizeof(checkpoint_name),\n             \"worker_%d_entry\", thread_id);\n    nemb_mark_checkpoint(checkpoint_name);\n\n    // Worker logic\n    volatile int sum = 0;\n    for (int i = 0; i &lt; 10000000; i++) {\n        sum += i;\n    }\n\n    snprintf(checkpoint_name, sizeof(checkpoint_name),\n             \"worker_%d_exit\", thread_id);\n    nemb_mark_checkpoint(checkpoint_name);\n}\n\nint main() {\n    nemb_initialize();\n    nemb_report_at_exit(nullptr);  // Print to stdout\n\n    std::vector&lt;std::thread&gt; threads;\n    for (int i = 0; i &lt; 4; i++) {\n        threads.emplace_back(worker, i);\n    }\n\n    for (auto&amp; t : threads) {\n        t.join();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"api/core/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/core/#runtime-configuration","title":"Runtime Configuration","text":"<p>Load custom configuration:</p> <pre><code>#include &lt;codegreen/config_loader.hpp&gt;\n\nint main() {\n    codegreen::ConfigLoader config(\"custom_config.json\");\n\n    // Configuration applied automatically\n    nemb_initialize();\n\n    // ...\n}\n</code></pre>"},{"location":"api/core/#provider-selection","title":"Provider Selection","text":"<p>Enable specific sensors:</p> <pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"providers\": {\n        \"intel_rapl\": { \"enabled\": true },\n        \"nvidia_nvml\": { \"enabled\": false }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/core/#error-handling","title":"Error Handling","text":"<p>NEMB uses return codes and error logging:</p> <pre><code>if (!nemb_initialize()) {\n    // Check system logs\n    // Possible causes:\n    // - No supported hardware sensors\n    // - Permission denied (RAPL)\n    // - Missing driver (NVML)\n    std::cerr &lt;&lt; \"Initialization failed\" &lt;&lt; std::endl;\n    return 1;\n}\n</code></pre> <p>Enable debug logging: <pre><code>export CODEGREEN_LOG_LEVEL=DEBUG\n./program\n</code></pre></p>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Architecture - NEMB design details</li> <li>Configuration Reference - Config options</li> <li>Building from Source - Build instructions</li> <li>Examples - C++ usage examples</li> </ul>"},{"location":"api/python/","title":"Python API","text":"<p>CodeGreen provides a comprehensive Python API for energy monitoring and analysis.</p>"},{"location":"api/python/#core-modules","title":"Core Modules","text":""},{"location":"api/python/#codegreencoreengine","title":"<code>codegreen.core.engine</code>","text":"<p>Main measurement engine for energy monitoring.</p> <pre><code>from codegreen.core import engine\n\n# Create engine instance\nengine = engine.MeasurementEngine()\n\n# Measure a function\n@engine.measure\ndef my_function():\n    # Your code here\n    pass\n\n# Get measurement results\nresult = engine.get_last_measurement()\n</code></pre>"},{"location":"api/python/#codegreencoreconfig","title":"<code>codegreen.core.config</code>","text":"<p>Configuration management.</p> <pre><code>from codegreen.core import config\n\n# Load configuration\nconfig = config.load_config()\n\n# Update settings\nconfig.set_precision(\"high\")\nconfig.set_timeout(60)\n</code></pre>"},{"location":"api/python/#codegreenutils","title":"<code>codegreen.utils</code>","text":"<p>Utility functions for platform detection and binary management.</p> <pre><code>from codegreen.utils import platform, binary\n\n# Check platform\nif platform.is_linux():\n    print(\"Running on Linux\")\n\n# Find CodeGreen binary\nbinary_path = binary.find_codegreen_binary()\n</code></pre>"},{"location":"api/python/#example-usage","title":"Example Usage","text":"<pre><code>import codegreen\nfrom codegreen.core import engine, config\n\n# Initialize\nconfig.load_config()\nengine = engine.MeasurementEngine()\n\n# Measure energy consumption\n@engine.measure\ndef compute_fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return compute_fibonacci(n-1) + compute_fibonacci(n-2)\n\n# Run measurement\nresult = compute_fibonacci(30)\n\n# Get energy data\nprint(f\"Energy consumed: {engine.get_last_measurement().total_joules} J\")\nprint(f\"Average power: {engine.get_last_measurement().average_watts} W\")\n</code></pre>"},{"location":"development/architecture/","title":"CodeGreen Architecture","text":"<p>Technical architecture overview for developers and contributors.</p>"},{"location":"development/architecture/#system-overview","title":"System Overview","text":"<p>CodeGreen is a hybrid Python-C++ system designed for high-performance, low-overhead energy measurement with language-agnostic code instrumentation.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         CLI Layer                            \u2502\n\u2502              (Python - Typer-based commands)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                               \u2502\n         v                               v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Instrumentation     \u2502      \u2502   Measurement        \u2502\n\u2502      Engine          \u2502      \u2502      Engine          \u2502\n\u2502  (Python/Tree-sitter)\u2502      \u2502   (C++ NEMB)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                               \u2502\n         v                               v\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AST Manipulation    \u2502      \u2502  Hardware Sensors    \u2502\n\u2502  Code Injection      \u2502      \u2502  (RAPL/NVML/ROCm)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#1-native-energy-measurement-backend-nemb","title":"1. Native Energy Measurement Backend (NEMB)","text":"<p>Location: <code>src/measurement/</code></p> <p>High-performance C++ measurement backend using signal-generator architecture.</p> <p>Architecture: <pre><code>// Signal-generator model\nApplication Thread (Fast Path):\n  mark_checkpoint(\"func_name\")\n    \u2514\u2500&gt; Record timestamp (~100-200ns)\n    \u2514\u2500&gt; Store in thread-local buffer\n    \u2514\u2500&gt; No I/O, no blocking\n\nBackground Thread (Measurement Path):\n  while (measuring):\n    poll_hardware_sensors()  // Every 1-100ms\n    store_in_circular_buffer()\n</code></pre></p> <p>Key Classes:</p> <ul> <li><code>MeasurementCoordinator</code>: Orchestrates multiple energy providers, manages background polling</li> <li><code>EnergyMeter</code>: Public API for checkpoint marking and correlation</li> <li><code>EnergyProvider</code>: Abstract interface for hardware sensors (RAPL, NVML, ROCm)</li> <li><code>PrecisionTimer</code>: High-resolution timestamping (TSC/CLOCK_MONOTONIC)</li> </ul> <p>Implementation Files: <pre><code>src/measurement/\n\u251c\u2500\u2500 include/nemb/\n\u2502   \u251c\u2500\u2500 codegreen_energy.hpp           # Public API\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u251c\u2500\u2500 measurement_coordinator.hpp\n\u2502   \u2502   \u2514\u2500\u2500 energy_provider.hpp\n\u2502   \u251c\u2500\u2500 drivers/\n\u2502   \u2502   \u251c\u2500\u2500 intel_rapl_provider.hpp\n\u2502   \u2502   \u2514\u2500\u2500 nvidia_nvml_provider.hpp\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u2514\u2500\u2500 precision_timer.hpp\n\u2514\u2500\u2500 src/nemb/\n    \u251c\u2500\u2500 codegreen_energy.cpp           # Checkpoint implementation\n    \u251c\u2500\u2500 core/\n    \u2502   \u2514\u2500\u2500 measurement_coordinator.cpp\n    \u2514\u2500\u2500 drivers/\n        \u251c\u2500\u2500 intel_rapl_provider.cpp\n        \u2514\u2500\u2500 nvidia_nvml_provider.cpp\n</code></pre></p>"},{"location":"development/architecture/#2-instrumentation-engine","title":"2. Instrumentation Engine","text":"<p>Location: <code>src/instrumentation/</code></p> <p>Python-based code instrumentation using Tree-sitter for AST parsing.</p> <p>Process Flow: <pre><code>1. Parse source code \u2192 AST (via Tree-sitter)\n2. Identify instrumentation points (function boundaries)\n3. Inject checkpoint calls at entry/exit points\n4. Generate instrumented code in temp directory\n5. Execute instrumented code\n6. Collect measurements from NEMB\n7. Attribute energy to source code locations\n</code></pre></p> <p>Key Modules:</p> <ul> <li><code>language_engine.py</code>: Multi-language coordinator</li> <li><code>ast_processor.py</code>: AST manipulation</li> <li><code>bridge_analyze.py</code>: AST analysis via Tree-sitter</li> <li><code>bridge_instrument.py</code>: Code instrumentation</li> <li><code>language_configs.py</code>: Language-specific queries</li> </ul> <p>Supported Languages: - Python (via tree-sitter-python) - C/C++ (via tree-sitter-c, tree-sitter-cpp) - Java (via tree-sitter-java) - Extensible via Tree-sitter grammars</p>"},{"location":"development/architecture/#3-cli-interface","title":"3. CLI Interface","text":"<p>Location: <code>src/cli/cli.py</code></p> <p>Typer-based command-line interface providing:</p> <pre><code>codegreen measure       # Instrument and measure code\ncodegreen analyze       # Static AST analysis\ncodegreen init          # System initialization\ncodegreen init-sensors  # Sensor permission setup\ncodegreen info          # System information\ncodegreen doctor        # Diagnostics\ncodegreen benchmark     # Built-in benchmarks\ncodegreen validate      # Accuracy validation\ncodegreen config        # Configuration management\n</code></pre>"},{"location":"development/architecture/#signal-generator-architecture","title":"Signal-Generator Architecture","text":""},{"location":"development/architecture/#problem-observer-effect","title":"Problem: Observer Effect","text":"<p>Traditional profilers perform synchronous hardware reads at each checkpoint:</p> <pre><code>// Synchronous model (V1 - high overhead)\nvoid checkpoint(const char* name) {\n    auto timestamp = get_time();\n    auto energy = read_rapl_file();  // ~5-20 \u03bcs I/O overhead\n    store_measurement(name, timestamp, energy);\n}\n</code></pre> <p>Overhead: 5-20 \u03bcs per checkpoint (FFI + file I/O + GIL)</p>"},{"location":"development/architecture/#solution-decoupled-measurement","title":"Solution: Decoupled Measurement","text":"<p>CodeGreen separates signal generation from measurement:</p> <pre><code>// Signal-generator model (V2 - NEMB)\nvoid mark_checkpoint(const char* name) {\n    auto timestamp = timer.get_timestamp_ns();  // ~100-200 ns\n    markers.push_back({name, timestamp});       // Thread-local\n}\n// No I/O, no blocking, no hardware access\n</code></pre> <p>Overhead: 100-200 ns per checkpoint (25-100x faster)</p> <p>Background thread polls hardware independently:</p> <pre><code>// Background measurement thread\nvoid measurement_loop() {\n    while (measuring) {\n        auto timestamp = timer.get_timestamp_ns();\n        auto energy = rapl_provider.read_energy();\n        buffer.push({timestamp, energy});\n        sleep_for(measurement_interval);  // 1-100ms\n    }\n}\n</code></pre>"},{"location":"development/architecture/#correlation-algorithm","title":"Correlation Algorithm","text":"<p>Post-execution, correlate checkpoints with energy readings:</p> <pre><code>double correlate_energy(uint64_t checkpoint_time) {\n    // Binary search for bounding energy readings\n    auto it = std::upper_bound(\n        energy_buffer.begin(),\n        energy_buffer.end(),\n        checkpoint_time,\n        [](uint64_t t, const Reading&amp; r) { return t &lt; r.timestamp; }\n    );\n\n    // Linear interpolation\n    const auto&amp; r1 = *(it - 1);\n    const auto&amp; r2 = *it;\n\n    double ratio = (checkpoint_time - r1.timestamp) /\n                   (r2.timestamp - r1.timestamp);\n\n    return r1.energy + ratio * (r2.energy - r1.energy);\n}\n</code></pre> <p>Accuracy: Sub-millisecond precision via interpolation, validated at \u00b12% error.</p>"},{"location":"development/architecture/#checkpoint-format","title":"Checkpoint Format","text":"<p>Checkpoints are uniquely identified with invocation tracking and thread IDs:</p> <pre><code>Format: &lt;function_name&gt;#inv_&lt;N&gt;_t&lt;THREAD_ID&gt;\nExamples:\n  - main#inv_1_t2069765334896692675\n  - process_data#inv_1_t2069765334896692675\n  - process_data#inv_2_t2069765334896692675    (recursive call)\n  - worker_loop#inv_1_t6293947261177266884     (different thread)\n</code></pre> <p>Implementation: <pre><code>void mark_checkpoint(const std::string&amp; name) {\n    thread_local std::unordered_map&lt;std::string, uint32_t&gt; invocation_counters;\n    thread_local std::hash&lt;std::thread::id&gt; hasher;\n    thread_local size_t thread_hash = hasher(std::this_thread::get_id());\n\n    uint32_t invocation = ++invocation_counters[name];\n    uint64_t ts = timer.get_timestamp_ns();\n\n    thread_local char enhanced_buffer[512];\n    int len = snprintf(enhanced_buffer, sizeof(enhanced_buffer),\n                       \"%s#inv_%u_t%zu\", name.c_str(), invocation, thread_hash);\n\n    std::lock_guard&lt;std::mutex&gt; lock(markers_mutex_);\n    markers.push_back({std::string(enhanced_buffer, len), ts});\n}\n</code></pre></p> <p>Benefits: - Handles recursive functions via invocation counter - Thread-safe via thread-local storage (no locks on fast path) - Unique identification across multi-threaded execution</p>"},{"location":"development/architecture/#multi-provider-coordination","title":"Multi-Provider Coordination","text":"<p>NEMB supports simultaneous measurement from multiple hardware sources:</p> <pre><code>class MeasurementCoordinator {\n    std::vector&lt;std::unique_ptr&lt;EnergyProvider&gt;&gt; providers_;\n\n    void start_measurement() {\n        for (auto&amp; provider : providers_) {\n            provider-&gt;start();\n        }\n\n        measurement_thread_ = std::thread([this]() {\n            while (running_) {\n                uint64_t timestamp = timer_.get_timestamp_ns();\n\n                for (auto&amp; provider : providers_) {\n                    auto energy = provider-&gt;read_energy();\n                    buffers_[provider-&gt;name()].push({timestamp, energy});\n                }\n\n                std::this_thread::sleep_for(\n                    std::chrono::milliseconds(measurement_interval_ms_));\n            }\n        });\n    }\n};\n</code></pre> <p>Supported Providers: - Intel RAPL: CPU package, cores, DRAM, integrated GPU - NVIDIA NVML: Discrete GPU energy - AMD ROCm: AMD GPU energy</p>"},{"location":"development/architecture/#tree-sitter-integration","title":"Tree-sitter Integration","text":""},{"location":"development/architecture/#language-agnostic-instrumentation","title":"Language-Agnostic Instrumentation","text":"<p>CodeGreen uses Tree-sitter for universal code analysis:</p> <pre><code># language_configs.py - Declarative queries\nPYTHON_QUERIES = {\n    \"function_definition\": \"\"\"\n        (function_definition\n            name: (identifier) @function.name\n            body: (block) @function.body)\n    \"\"\",\n    \"class_definition\": \"\"\"\n        (class_definition\n            name: (identifier) @class.name\n            body: (block) @class.body)\n    \"\"\"\n}\n\nCPP_QUERIES = {\n    \"function_definition\": \"\"\"\n        (function_definition\n            declarator: (function_declarator\n                declarator: (identifier) @function.name)\n            body: (compound_statement) @function.body)\n    \"\"\"\n}\n</code></pre>"},{"location":"development/architecture/#instrumentation-process","title":"Instrumentation Process","text":"<pre><code># bridge_instrument.py\ndef instrument_function(node, source_code):\n    func_name = extract_name(node)\n    body_node = extract_body(node)\n\n    # Inject entry checkpoint\n    entry_checkpoint = f'codegreen_checkpoint(\"{func_name}_entry\")'\n    instrumented_code = inject_at_start(body_node, entry_checkpoint)\n\n    # Inject exit checkpoints (before all returns)\n    for return_stmt in find_return_statements(body_node):\n        exit_checkpoint = f'codegreen_checkpoint(\"{func_name}_exit\")'\n        instrumented_code = inject_before(return_stmt, exit_checkpoint)\n\n    return instrumented_code\n</code></pre>"},{"location":"development/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"development/architecture/#overhead-analysis","title":"Overhead Analysis","text":"Component Overhead Measurement Checkpoint marking 100-200 ns Per function call Background polling &lt;0.1% CPU 1 thread @ 1-100ms interval Circular buffer ~10 KB Per provider Total system overhead &lt;1% High precision mode"},{"location":"development/architecture/#memory-usage","title":"Memory Usage","text":"<pre><code>Base NEMB library:     ~500 KB\nCircular buffers:      ~10 KB per provider\nCheckpoint markers:    ~100 bytes per checkpoint\nPython runtime:        ~50 MB\n</code></pre>"},{"location":"development/architecture/#accuracy-validation","title":"Accuracy Validation","text":"<p>Long-running workloads: <pre><code>CodeGreen: 801.96 J\nperf:      834.30 J\nDelta:     -3.88% (within \u00b12% target for algorithm energy)\n</code></pre></p> <p>Short-running workloads: <pre><code>CodeGreen: 0.23 J  (algorithm only)\nperf:      2.40 J  (includes runtime overhead)\nDelta:     -90% (intentional - filters startup cost)\n</code></pre></p>"},{"location":"development/architecture/#configuration-system","title":"Configuration System","text":"<p>Location: <code>config/codegreen.json</code></p> <pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1,\n        \"measurement_buffer_size\": 100000\n      },\n      \"timing\": {\n        \"precision\": \"high\",\n        \"clock_source\": \"auto\"\n      },\n      \"providers\": {\n        \"intel_rapl\": { \"enabled\": true },\n        \"nvidia_nvml\": { \"enabled\": true }\n      }\n    }\n  },\n  \"instrumentation\": {\n    \"checkpoint_strategy\": \"functions\",\n    \"track_invocations\": true,\n    \"track_threads\": true\n  }\n}\n</code></pre> <p>Config loader: <code>src/measurement/src/nemb/config_loader.cpp</code></p>"},{"location":"development/architecture/#build-system","title":"Build System","text":"<p>CMake-based build: <pre><code># CMakeLists.txt\nproject(codegreen-nemb CXX)\n\nadd_library(codegreen-nemb SHARED\n    src/codegreen_energy.cpp\n    src/core/measurement_coordinator.cpp\n    src/drivers/intel_rapl_provider.cpp\n    src/drivers/nvidia_nvml_provider.cpp\n)\n\ntarget_link_libraries(codegreen-nemb\n    pthread\n    jsoncpp\n)\n</code></pre></p> <p>Installation: <pre><code>./install.sh          # Automated build + install\n# OR manual:\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\n</code></pre></p>"},{"location":"development/architecture/#extension-points","title":"Extension Points","text":""},{"location":"development/architecture/#adding-new-languages","title":"Adding New Languages","text":"<ol> <li>Add Tree-sitter grammar to <code>third_party/tree-sitter-&lt;lang&gt;</code></li> <li>Create language queries in <code>language_configs.py</code></li> <li>Test instrumentation with example programs</li> </ol>"},{"location":"development/architecture/#adding-new-hardware-sensors","title":"Adding New Hardware Sensors","text":"<ol> <li>Implement <code>EnergyProvider</code> interface</li> <li>Add provider to <code>MeasurementCoordinator</code></li> <li>Update configuration schema</li> </ol>"},{"location":"development/architecture/#custom-instrumentation-strategies","title":"Custom Instrumentation Strategies","text":"<p>Modify <code>bridge_instrument.py</code> to change checkpoint placement (e.g., loop-level, block-level).</p>"},{"location":"development/architecture/#see-also","title":"See Also","text":"<ul> <li>Building from Source - Complete build instructions</li> <li>Contributing Guide - Development workflow</li> <li>Configuration Reference - Config options</li> </ul>"},{"location":"development/building/","title":"Building from Source","text":"<p>Complete guide to building CodeGreen from source for development and contribution.</p>"},{"location":"development/building/#prerequisites","title":"Prerequisites","text":""},{"location":"development/building/#system-requirements","title":"System Requirements","text":"<ul> <li>Operating System: Linux (Ubuntu 20.04+, Fedora 33+, Arch Linux)</li> <li>CPU: x86_64 architecture (Intel/AMD)</li> <li>Memory: 2 GB RAM minimum, 4 GB recommended</li> <li>Disk: 1 GB free space</li> </ul>"},{"location":"development/building/#required-tools","title":"Required Tools","text":"<p>Build Tools: <pre><code># Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install -y \\\n    build-essential \\\n    cmake \\\n    pkg-config \\\n    git\n\n# Fedora\nsudo dnf install -y \\\n    gcc gcc-c++ \\\n    cmake \\\n    pkg-config \\\n    git\n\n# Arch Linux\nsudo pacman -S --noconfirm \\\n    base-devel \\\n    cmake \\\n    pkg-config \\\n    git\n</code></pre></p> <p>C++ Compiler: - GCC 7+ or Clang 10+ with C++17 support - CMake 3.16+</p> <p>Python: <pre><code># Ubuntu/Debian\nsudo apt-get install -y python3 python3-pip python3-dev\n\n# Fedora\nsudo dnf install -y python3 python3-pip python3-devel\n\n# Arch Linux\nsudo pacman -S --noconfirm python python-pip\n</code></pre></p>"},{"location":"development/building/#required-libraries","title":"Required Libraries","text":"<p>C++ Dependencies: <pre><code># Ubuntu/Debian\nsudo apt-get install -y \\\n    libjsoncpp-dev \\\n    libcurl4-openssl-dev \\\n    libsqlite3-dev\n\n# Fedora\nsudo dnf install -y \\\n    jsoncpp-devel \\\n    libcurl-devel \\\n    sqlite-devel\n\n# Arch Linux\nsudo pacman -S --noconfirm \\\n    jsoncpp \\\n    curl \\\n    sqlite\n</code></pre></p> <p>Python Dependencies: <pre><code>pip3 install -r requirements.txt\n</code></pre></p>"},{"location":"development/building/#quick-build","title":"Quick Build","text":""},{"location":"development/building/#automated-installation","title":"Automated Installation","text":"<p>Fastest way to build and install:</p> <pre><code>git clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\n./install.sh\n</code></pre> <p>This script: 1. Installs system dependencies (requires sudo) 2. Builds NEMB (C++ measurement backend) 3. Installs Python CLI 4. Sets up binary in <code>/usr/local/bin</code></p>"},{"location":"development/building/#manual-build","title":"Manual Build","text":"<p>For development or custom installation:</p> <pre><code>git clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\n\n# Initialize submodules\ngit submodule update --init --recursive\n\n# Build C++ NEMB library\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\n\n# Install library\nsudo make install\nsudo ldconfig\n\n# Install Python CLI\ncd ..\npip3 install -e .\n</code></pre>"},{"location":"development/building/#build-configurations","title":"Build Configurations","text":""},{"location":"development/building/#debug-build","title":"Debug Build","text":"<p>For development with debug symbols:</p> <pre><code>mkdir build-debug &amp;&amp; cd build-debug\ncmake .. -DCMAKE_BUILD_TYPE=Debug\nmake -j$(nproc)\n</code></pre> <p>Features: - Debug symbols included - Assertions enabled - No optimization (-O0) - Larger binary size</p>"},{"location":"development/building/#release-build","title":"Release Build","text":"<p>For production with optimizations:</p> <pre><code>mkdir build-release &amp;&amp; cd build-release\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\n</code></pre> <p>Features: - Full optimizations (-O3) - Debug symbols stripped - Smaller binary size - Maximum performance</p>"},{"location":"development/building/#relwithdebinfo-build","title":"RelWithDebInfo Build","text":"<p>For profiling with debug info:</p> <pre><code>mkdir build-profile &amp;&amp; cd build-profile\ncmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo\nmake -j$(nproc)\n</code></pre> <p>Features: - Optimizations enabled (-O2) - Debug symbols retained - Good for profiling</p>"},{"location":"development/building/#build-options","title":"Build Options","text":""},{"location":"development/building/#cmake-configuration-options","title":"CMake Configuration Options","text":"<pre><code>cmake .. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_INSTALL_PREFIX=/usr/local \\\n    -DBUILD_TESTS=ON \\\n    -DBUILD_EXAMPLES=ON \\\n    -DENABLE_CUDA=OFF\n</code></pre> <p>Available Options:</p> Option Default Description <code>CMAKE_BUILD_TYPE</code> Release Build type (Debug/Release/RelWithDebInfo) <code>CMAKE_INSTALL_PREFIX</code> /usr/local Installation directory <code>BUILD_TESTS</code> ON Build unit tests <code>BUILD_EXAMPLES</code> OFF Build example programs <code>ENABLE_CUDA</code> OFF Enable CUDA support (requires CUDA Toolkit) <code>ENABLE_ROCM</code> OFF Enable AMD ROCm support"},{"location":"development/building/#compiler-selection","title":"Compiler Selection","text":"<p>Use specific compiler:</p> <pre><code># GCC\ncmake .. -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++\n\n# Clang\ncmake .. -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++\n</code></pre>"},{"location":"development/building/#development-build","title":"Development Build","text":""},{"location":"development/building/#editable-install","title":"Editable Install","text":"<p>For active development:</p> <pre><code># Install Python package in editable mode\npip3 install -e .\n\n# Changes to Python code take effect immediately\n# No need to reinstall after editing\n</code></pre>"},{"location":"development/building/#build-nemb-library-only","title":"Build NEMB Library Only","text":"<p>When working on C++ components:</p> <pre><code>cd build\nmake -j$(nproc)\nsudo make install\nsudo ldconfig\n</code></pre>"},{"location":"development/building/#running-tests","title":"Running Tests","text":"<p>After building with <code>BUILD_TESTS=ON</code>:</p> <pre><code># C++ tests\ncd build\nctest --output-on-failure\n\n# Python tests\npytest tests/\n</code></pre>"},{"location":"development/building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/building/#cmake-configuration-fails","title":"CMake Configuration Fails","text":"<p>Problem: <code>Could not find required library: jsoncpp</code></p> <p>Solution: <pre><code># Ubuntu/Debian\nsudo apt-get install libjsoncpp-dev\n\n# Fedora\nsudo dnf install jsoncpp-devel\n\n# Arch Linux\nsudo pacman -S jsoncpp\n</code></pre></p>"},{"location":"development/building/#compilation-errors","title":"Compilation Errors","text":"<p>Problem: <code>error: 'std::filesystem' has not been declared</code></p> <p>Solution: Update to GCC 8+ or Clang 10+: <pre><code># Ubuntu 20.04\nsudo apt-get install gcc-10 g++-10\ncmake .. -DCMAKE_C_COMPILER=gcc-10 -DCMAKE_CXX_COMPILER=g++-10\n</code></pre></p>"},{"location":"development/building/#linker-errors","title":"Linker Errors","text":"<p>Problem: <code>undefined reference to 'Json::Value::Value()'</code></p> <p>Solution: Ensure libjsoncpp is installed and ldconfig is run: <pre><code>sudo ldconfig\n</code></pre></p>"},{"location":"development/building/#permission-errors-during-install","title":"Permission Errors During Install","text":"<p>Problem: <code>Permission denied</code> when running <code>make install</code></p> <p>Solution: Use sudo for system installation: <pre><code>sudo make install\nsudo ldconfig\n</code></pre></p> <p>Or install to user directory: <pre><code>cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/.local\nmake install\nexport PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre></p>"},{"location":"development/building/#import-errors-in-python","title":"Import Errors in Python","text":"<p>Problem: <code>ModuleNotFoundError: No module named 'codegreen'</code></p> <p>Solution: <pre><code># Reinstall Python package\npip3 install -e .\n\n# Or add to PYTHONPATH\nexport PYTHONPATH=\"$PWD:$PYTHONPATH\"\n</code></pre></p>"},{"location":"development/building/#cross-compilation","title":"Cross-Compilation","text":""},{"location":"development/building/#arm64-aarch64","title":"ARM64 (aarch64)","text":"<pre><code># Install cross-compiler\nsudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n\n# Configure for ARM64\ncmake .. \\\n    -DCMAKE_SYSTEM_NAME=Linux \\\n    -DCMAKE_SYSTEM_PROCESSOR=aarch64 \\\n    -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \\\n    -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++\n\nmake -j$(nproc)\n</code></pre>"},{"location":"development/building/#packaging","title":"Packaging","text":""},{"location":"development/building/#debianubuntu-package","title":"Debian/Ubuntu Package","text":"<pre><code># Install packaging tools\nsudo apt-get install debhelper dh-make\n\n# Create package\ncd codegreen\ndpkg-buildpackage -us -uc\n\n# Install\nsudo dpkg -i ../codegreen_0.1.0_amd64.deb\n</code></pre>"},{"location":"development/building/#rpm-package-fedorarhel","title":"RPM Package (Fedora/RHEL)","text":"<pre><code># Install packaging tools\nsudo dnf install rpm-build rpmdevtools\n\n# Create package\ncd codegreen\nrpmbuild -ba codegreen.spec\n\n# Install\nsudo rpm -i ~/rpmbuild/RPMS/x86_64/codegreen-0.1.0-1.x86_64.rpm\n</code></pre>"},{"location":"development/building/#verification","title":"Verification","text":"<p>After building, verify installation:</p> <pre><code># Check binary\nwhich codegreen\ncodegreen --version\n\n# Check library\nldconfig -p | grep codegreen\n\n# Run doctor\ncodegreen doctor --verbose\n\n# Run validation test\nsudo codegreen validate --quick\n</code></pre>"},{"location":"development/building/#clean-build","title":"Clean Build","text":"<p>Remove build artifacts:</p> <pre><code># Clean CMake build\nrm -rf build/\n\n# Clean Python build\nrm -rf build/ dist/ *.egg-info\npip3 uninstall codegreen\n\n# Full clean (including submodules)\ngit clean -fdx\ngit submodule foreach --recursive git clean -fdx\n</code></pre>"},{"location":"development/building/#see-also","title":"See Also","text":"<ul> <li>Contributing Guide - Development workflow</li> <li>Architecture - System design</li> <li>Installation - User installation</li> </ul>"},{"location":"development/contributing/","title":"Contributing to CodeGreen","text":"<p>Thank you for your interest in contributing to CodeGreen! This guide will help you get started.</p>"},{"location":"development/contributing/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Fork the Repository <pre><code># Fork on GitHub, then clone your fork\ngit clone https://github.com/YOUR_USERNAME/codegreen.git\ncd codegreen\n</code></pre></p> </li> <li> <p>Set Up Development Environment <pre><code># Add upstream remote\ngit remote add upstream https://github.com/SMART-Dal/codegreen.git\n\n# Install dependencies\n./install.sh\n\n# Or manual setup\npip3 install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Create a Branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make Changes and Test <pre><code># Make your changes\n\n# Run tests\npytest tests/\ncd build &amp;&amp; ctest\n\n# Verify functionality\ncodegreen doctor\n</code></pre></p> </li> <li> <p>Submit Pull Request <pre><code>git push origin feature/your-feature-name\n# Open PR on GitHub\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branch-strategy","title":"Branch Strategy","text":"<ul> <li><code>main</code>: Stable release branch</li> <li><code>develop</code>: Integration branch for features</li> <li><code>feature/*</code>: New features</li> <li><code>bugfix/*</code>: Bug fixes</li> <li><code>hotfix/*</code>: Urgent production fixes</li> </ul>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style/formatting - <code>refactor</code>: Code refactoring - <code>perf</code>: Performance improvement - <code>test</code>: Adding/updating tests - <code>build</code>: Build system changes - <code>ci</code>: CI/CD changes</p> <p>Examples: <pre><code>git commit -m \"feat(nemb): add AMD ROCm GPU support\"\ngit commit -m \"fix(cli): resolve RAPL permission error on Ubuntu 22.04\"\ngit commit -m \"docs(examples): add Java energy profiling examples\"\n</code></pre></p>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>C++ (NEMB): - Follow Google C++ Style Guide - Use <code>clang-format</code> for formatting - Header guards: <code>CODEGREEN_&lt;PATH&gt;_&lt;FILE&gt;_HPP</code></p> <pre><code>// Good\nnamespace codegreen {\n\nclass MeasurementCoordinator {\npublic:\n    void start_measurement();\n\nprivate:\n    std::vector&lt;std::unique_ptr&lt;EnergyProvider&gt;&gt; providers_;\n};\n\n}  // namespace codegreen\n</code></pre> <p>Python: - Follow PEP 8 - Use <code>black</code> for formatting - Use <code>ruff</code> for linting</p> <pre><code># Format code\nblack src/\n\n# Lint code\nruff check src/\n</code></pre>"},{"location":"development/contributing/#testing-requirements","title":"Testing Requirements","text":"<p>All contributions must include tests:</p> <p>C++ Tests (Google Test): <pre><code>// tests/nemb/test_measurement_coordinator.cpp\n#include &lt;gtest/gtest.h&gt;\n#include \"nemb/core/measurement_coordinator.hpp\"\n\nTEST(MeasurementCoordinatorTest, StartStopMeasurement) {\n    codegreen::MeasurementCoordinator coordinator;\n    ASSERT_TRUE(coordinator.start());\n    ASSERT_TRUE(coordinator.stop());\n}\n</code></pre></p> <p>Python Tests (pytest): <pre><code># tests/test_cli.py\ndef test_measure_command():\n    result = subprocess.run(\n        [\"codegreen\", \"measure\", \"python\", \"test_script.py\"],\n        capture_output=True,\n        text=True\n    )\n    assert result.returncode == 0\n    assert \"Energy\" in result.stdout\n</code></pre></p> <p>Run Tests: <pre><code># C++ tests\ncd build\ncmake .. -DBUILD_TESTS=ON\nmake\nctest --output-on-failure\n\n# Python tests\npytest tests/ -v\n\n# Coverage\npytest tests/ --cov=src --cov-report=html\n</code></pre></p>"},{"location":"development/contributing/#areas-for-contribution","title":"Areas for Contribution","text":""},{"location":"development/contributing/#1-new-language-support","title":"1. New Language Support","text":"<p>Add support for additional programming languages:</p> <p>Steps: 1. Add Tree-sitter grammar to <code>third_party/</code> 2. Create language queries in <code>src/instrumentation/language_configs.py</code> 3. Add runtime wrapper in <code>runtime/</code> 4. Add tests and examples</p> <p>Example PR: Adding Rust support</p>"},{"location":"development/contributing/#2-hardware-sensor-drivers","title":"2. Hardware Sensor Drivers","text":"<p>Implement new energy measurement providers:</p> <p>Steps: 1. Create provider class in <code>src/measurement/src/nemb/drivers/</code> 2. Implement <code>EnergyProvider</code> interface 3. Register in <code>MeasurementCoordinator</code> 4. Add configuration options 5. Document hardware requirements</p> <p>Example: ARM Mali GPU support</p>"},{"location":"development/contributing/#3-documentation-improvements","title":"3. Documentation Improvements","text":"<ul> <li>Fix typos and unclear explanations</li> <li>Add usage examples</li> <li>Improve API documentation</li> <li>Translate to other languages</li> </ul>"},{"location":"development/contributing/#4-bug-fixes","title":"4. Bug Fixes","text":"<ul> <li>Check Issues for bugs</li> <li>Reproduce the issue</li> <li>Write failing test</li> <li>Implement fix</li> <li>Verify test passes</li> </ul>"},{"location":"development/contributing/#5-performance-optimizations","title":"5. Performance Optimizations","text":"<ul> <li>Profile measurement overhead</li> <li>Optimize hot paths</li> <li>Reduce memory allocations</li> <li>Benchmark improvements</li> </ul>"},{"location":"development/contributing/#code-review-process","title":"Code Review Process","text":"<ol> <li>Automated Checks</li> <li>CI/CD pipeline runs automatically</li> <li>All tests must pass</li> <li> <p>Code coverage should not decrease</p> </li> <li> <p>Review by Maintainers</p> </li> <li>At least one maintainer approval required</li> <li>Address review comments</li> <li> <p>Update code based on feedback</p> </li> <li> <p>Merge</p> </li> <li>Squash commits if needed</li> <li>Merge to <code>develop</code> branch</li> <li>Delete feature branch</li> </ol>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#required-tools","title":"Required Tools","text":"<pre><code># Formatting tools\npip3 install black ruff\n\n# Testing tools\npip3 install pytest pytest-cov\n\n# C++ tools\nsudo apt-get install clang-format clang-tidy\n</code></pre>"},{"location":"development/contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Install pre-commit hooks to automatically check code:</p> <pre><code>pip3 install pre-commit\npre-commit install\n</code></pre> <p>This runs before each commit: - <code>black</code>: Python formatting - <code>ruff</code>: Python linting - <code>clang-format</code>: C++ formatting - <code>pytest</code>: Python tests</p>"},{"location":"development/contributing/#ide-setup","title":"IDE Setup","text":"<p>VS Code: <pre><code>// .vscode/settings.json\n{\n    \"python.formatting.provider\": \"black\",\n    \"python.linting.enabled\": true,\n    \"python.linting.ruffEnabled\": true,\n    \"C_Cpp.clang_format_style\": \"Google\"\n}\n</code></pre></p> <p>CLion/PyCharm: - Enable Google C++ style - Configure Black as Python formatter - Enable Ruff linter</p>"},{"location":"development/contributing/#debugging","title":"Debugging","text":""},{"location":"development/contributing/#debug-build","title":"Debug Build","text":"<pre><code>mkdir build-debug &amp;&amp; cd build-debug\ncmake .. -DCMAKE_BUILD_TYPE=Debug\nmake -j$(nproc)\n</code></pre>"},{"location":"development/contributing/#gdb-debugging","title":"GDB Debugging","text":"<pre><code># Debug the binary\ngdb --args build-debug/bin/codegreen measure python test.py\n\n# Common commands\n(gdb) break codegreen_energy.cpp:123\n(gdb) run\n(gdb) backtrace\n(gdb) print variable_name\n</code></pre>"},{"location":"development/contributing/#python-debugging","title":"Python Debugging","text":"<pre><code># Add breakpoint\nimport pdb; pdb.set_trace()\n\n# Or use debugger\npython -m pdb src/cli/cli.py measure python test.py\n</code></pre>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>Include: - CodeGreen version (<code>codegreen --version</code>) - Operating system and version - Hardware details (<code>codegreen info --verbose</code>) - Steps to reproduce - Expected vs actual behavior - Error messages/logs</p> <p>Template: <pre><code>**Bug Description**\nBrief description of the issue\n\n**To Reproduce**\n1. Run `codegreen measure python script.py`\n2. See error\n\n**Expected Behavior**\nShould measure energy without error\n\n**Environment**\n- CodeGreen version: 0.1.0\n- OS: Ubuntu 22.04\n- CPU: Intel i7-9750H\n- Output of `codegreen doctor --verbose`\n\n**Logs**\n</code></pre> [error logs here] <pre><code>\n</code></pre></p>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>Include: - Use case description - Proposed solution - Alternative approaches considered - Willingness to implement</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: docs.codegreen.io</li> <li>Discussions: GitHub Discussions</li> <li>Issues: GitHub Issues</li> <li>Email: dev@codegreen.io</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - <code>AUTHORS.md</code> file - Release notes - GitHub contributors page</p> <p>Thank you for making CodeGreen better!</p>"},{"location":"examples/cpp/","title":"C/C++ Examples","text":"<p>Practical examples of using CodeGreen with C and C++ programs.</p>"},{"location":"examples/cpp/#basic-c-energy-measurement","title":"Basic C++ Energy Measurement","text":"<pre><code>// matrix_multiply.cpp\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\ndouble matrix_multiply(int size) {\n    std::vector&lt;std::vector&lt;double&gt;&gt; a(size, std::vector&lt;double&gt;(size, 1.0));\n    std::vector&lt;std::vector&lt;double&gt;&gt; b(size, std::vector&lt;double&gt;(size, 2.0));\n    std::vector&lt;std::vector&lt;double&gt;&gt; c(size, std::vector&lt;double&gt;(size, 0.0));\n\n    for (int i = 0; i &lt; size; i++) {\n        for (int j = 0; j &lt; size; j++) {\n            for (int k = 0; k &lt; size; k++) {\n                c[i][j] += a[i][k] * b[k][j];\n            }\n        }\n    }\n\n    // Return result to prevent dead code elimination\n    return c[0][0];\n}\n\nint main() {\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; matrix_multiply(500) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure cpp matrix_multiply.cpp --precision high --output results.json\n</code></pre></p>"},{"location":"examples/cpp/#c-example-with-multiple-functions","title":"C Example with Multiple Functions","text":"<pre><code>// compute.c\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble compute_pi(int iterations) {\n    double pi = 0.0;\n    for (int i = 0; i &lt; iterations; i++) {\n        pi += (i % 2 == 0 ? 1.0 : -1.0) / (2.0 * i + 1.0);\n    }\n    return pi * 4.0;\n}\n\ndouble factorial(int n) {\n    double result = 1.0;\n    for (int i = 2; i &lt;= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nint main() {\n    double pi = compute_pi(10000000);\n    double fact = factorial(100);\n\n    printf(\"Pi approximation: %.10f\\n\", pi);\n    printf(\"Factorial result: %.2e\\n\", fact);\n\n    return 0;\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure c compute.c --precision high --json\n</code></pre></p>"},{"location":"examples/cpp/#algorithm-comparison","title":"Algorithm Comparison","text":"<p>Compare energy consumption of different sorting algorithms:</p> <pre><code>// sorting_comparison.cpp\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;random&gt;\n\nstd::vector&lt;int&gt; generate_data(int size) {\n    std::vector&lt;int&gt; data(size);\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution&lt;&gt; dis(1, 10000);\n\n    for (int i = 0; i &lt; size; i++) {\n        data[i] = dis(gen);\n    }\n    return data;\n}\n\nint bubble_sort(std::vector&lt;int&gt; arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                std::swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n    return arr[0];  // Return to prevent DCE\n}\n\nint merge_sort_impl(std::vector&lt;int&gt;&amp; arr, int left, int right) {\n    if (left &gt;= right) return 0;\n\n    int mid = left + (right - left) / 2;\n    merge_sort_impl(arr, left, mid);\n    merge_sort_impl(arr, mid + 1, right);\n\n    std::vector&lt;int&gt; temp(right - left + 1);\n    int i = left, j = mid + 1, k = 0;\n\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        temp[k++] = (arr[i] &lt;= arr[j]) ? arr[i++] : arr[j++];\n    }\n    while (i &lt;= mid) temp[k++] = arr[i++];\n    while (j &lt;= right) temp[k++] = arr[j++];\n\n    for (int i = 0; i &lt; k; i++) {\n        arr[left + i] = temp[i];\n    }\n    return arr[left];\n}\n\nint merge_sort(std::vector&lt;int&gt; arr) {\n    merge_sort_impl(arr, 0, arr.size() - 1);\n    return arr[0];\n}\n\nint main() {\n    auto data = generate_data(5000);\n\n    std::cout &lt;&lt; \"Bubble sort result: \" &lt;&lt; bubble_sort(data) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Merge sort result: \" &lt;&lt; merge_sort(data) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Measure and compare: <pre><code>codegreen measure cpp sorting_comparison.cpp --precision high --output sorting_energy.json\n</code></pre></p> <p>Expected output: <pre><code>{\n  \"functions\": {\n    \"bubble_sort\": {\n      \"total_energy_joules\": 12.45,\n      \"execution_time_ms\": 1250.3,\n      \"average_power_watts\": 9.96\n    },\n    \"merge_sort\": {\n      \"total_energy_joules\": 0.85,\n      \"execution_time_ms\": 85.2,\n      \"average_power_watts\": 9.98\n    }\n  }\n}\n</code></pre></p>"},{"location":"examples/cpp/#optimization-example","title":"Optimization Example","text":"<p>Measure before and after optimization:</p> <p>Before (cache-unfriendly): <pre><code>// matrix_transpose_slow.cpp\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ndouble transpose_slow(int size) {\n    std::vector&lt;std::vector&lt;double&gt;&gt; matrix(size, std::vector&lt;double&gt;(size));\n    std::vector&lt;std::vector&lt;double&gt;&gt; result(size, std::vector&lt;double&gt;(size));\n\n    // Initialize\n    for (int i = 0; i &lt; size; i++)\n        for (int j = 0; j &lt; size; j++)\n            matrix[i][j] = i * size + j;\n\n    // Transpose (column-major access - cache unfriendly)\n    for (int j = 0; j &lt; size; j++)\n        for (int i = 0; i &lt; size; i++)\n            result[i][j] = matrix[j][i];\n\n    return result[0][0];\n}\n\nint main() {\n    std::cout &lt;&lt; transpose_slow(2000) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p> <p>After (cache-friendly): <pre><code>// matrix_transpose_fast.cpp\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ndouble transpose_fast(int size) {\n    std::vector&lt;std::vector&lt;double&gt;&gt; matrix(size, std::vector&lt;double&gt;(size));\n    std::vector&lt;std::vector&lt;double&gt;&gt; result(size, std::vector&lt;double&gt;(size));\n\n    // Initialize\n    for (int i = 0; i &lt; size; i++)\n        for (int j = 0; j &lt; size; j++)\n            matrix[i][j] = i * size + j;\n\n    // Transpose (row-major access - cache friendly)\n    for (int i = 0; i &lt; size; i++)\n        for (int j = 0; j &lt; size; j++)\n            result[j][i] = matrix[i][j];\n\n    return result[0][0];\n}\n\nint main() {\n    std::cout &lt;&lt; transpose_fast(2000) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p> <p>Measure both: <pre><code>codegreen measure cpp matrix_transpose_slow.cpp --output slow.json\ncodegreen measure cpp matrix_transpose_fast.cpp --output fast.json\n</code></pre></p> <p>Energy savings: Cache-friendly version typically uses 15-30% less energy.</p>"},{"location":"examples/cpp/#working-with-nemb-runtime-directly","title":"Working with NEMB Runtime Directly","text":"<p>For advanced users who want direct checkpoint control:</p> <pre><code>// manual_checkpoints.cpp\n#include &lt;iostream&gt;\n#include &lt;codegreen_runtime.h&gt;\n\ndouble heavy_computation() {\n    double sum = 0.0;\n    for (int i = 0; i &lt; 10000000; i++) {\n        sum += sin(i) * cos(i);\n    }\n    return sum;\n}\n\nint main() {\n    nemb_initialize();\n\n    nemb_mark_checkpoint(\"main_start\");\n\n    double result = heavy_computation();\n\n    nemb_mark_checkpoint(\"computation_done\");\n\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result &lt;&lt; std::endl;\n\n    nemb_mark_checkpoint(\"main_end\");\n\n    return 0;\n}\n</code></pre> <p>Compile and run: <pre><code>g++ -o manual_checkpoints manual_checkpoints.cpp -lcodegreen-nemb -lm\n./manual_checkpoints\n</code></pre></p>"},{"location":"examples/cpp/#build-options","title":"Build Options","text":""},{"location":"examples/cpp/#recommended-compiler-flags","title":"Recommended Compiler Flags","text":"<p>For accurate measurements, disable optimizations during profiling:</p> <pre><code># Debug build (no optimizations)\ng++ -O0 -g program.cpp -o program\n\n# Measure with CodeGreen\ncodegreen measure cpp program.cpp\n</code></pre>"},{"location":"examples/cpp/#production-optimization-comparison","title":"Production Optimization Comparison","text":"<p>Compare energy across optimization levels:</p> <pre><code># Measure O0\ng++ -O0 program.cpp -o program_O0\ncodegreen measure --instrumented ./program_O0 --output O0.json\n\n# Measure O2\ng++ -O2 program.cpp -o program_O2\ncodegreen measure --instrumented ./program_O2 --output O2.json\n\n# Measure O3\ng++ -O3 program.cpp -o program_O3\ncodegreen measure --instrumented ./program_O3 --output O3.json\n</code></pre>"},{"location":"examples/cpp/#best-practices","title":"Best Practices","text":"<ol> <li>Prevent Dead Code Elimination: Always use computation results (return, print, or volatile)</li> <li>Disable Optimizations: Use <code>-O0</code> during profiling for accurate attribution</li> <li>Warm-up Iterations: Run once before measuring to avoid cold-start overhead</li> <li>Consistent Input: Use same data for algorithm comparisons</li> <li>Multiple Runs: Average results across 3-5 runs for stability</li> </ol>"},{"location":"examples/cpp/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command options</li> <li>Configuration - Compiler flag settings</li> <li>Python Examples - Python energy profiling</li> </ul>"},{"location":"examples/java/","title":"Java Examples","text":"<p>Practical examples of using CodeGreen with Java programs.</p>"},{"location":"examples/java/#basic-energy-measurement","title":"Basic Energy Measurement","text":"<pre><code>// Fibonacci.java\npublic class Fibonacci {\n\n    public static long fibonacci(int n) {\n        if (n &lt;= 1) return n;\n\n        long a = 0, b = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            long temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        long result = fibonacci(1000000);\n        System.out.println(\"Fibonacci result: \" + result);\n    }\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure java Fibonacci.java --precision high --output results.json\n</code></pre></p>"},{"location":"examples/java/#algorithm-comparison","title":"Algorithm Comparison","text":"<p>Compare energy consumption of different sorting implementations:</p> <pre><code>// SortingComparison.java\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class SortingComparison {\n\n    private static int[] generateData(int size) {\n        Random rand = new Random(42);\n        int[] data = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            data[i] = rand.nextInt(10000);\n        }\n        return data;\n    }\n\n    public static int bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i &lt; n - 1; i++) {\n            for (int j = 0; j &lt; n - i - 1; j++) {\n                if (arr[j] &gt; arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        return arr[0];\n    }\n\n    public static int quickSort(int[] arr, int low, int high) {\n        if (low &lt; high) {\n            int pi = partition(arr, low, high);\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n        return arr.length &gt; 0 ? arr[0] : 0;\n    }\n\n    private static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n\n        for (int j = low; j &lt; high; j++) {\n            if (arr[j] &lt; pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1;\n    }\n\n    public static void main(String[] args) {\n        int[] data1 = generateData(5000);\n        int[] data2 = Arrays.copyOf(data1, data1.length);\n\n        System.out.println(\"Bubble sort result: \" + bubbleSort(data1));\n        System.out.println(\"Quick sort result: \" + quickSort(data2, 0, data2.length - 1));\n    }\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure java SortingComparison.java --precision high --output sorting_energy.json\n</code></pre></p>"},{"location":"examples/java/#data-processing-example","title":"Data Processing Example","text":"<p>Real-world data processing scenario:</p> <pre><code>// DataProcessor.java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class DataProcessor {\n\n    static class Record {\n        String id;\n        double value;\n\n        Record(String id, double value) {\n            this.id = id;\n            this.value = value;\n        }\n    }\n\n    public static List&lt;Record&gt; generateRecords(int count) {\n        List&lt;Record&gt; records = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; count; i++) {\n            records.add(new Record(\"ID\" + i, Math.random() * 1000));\n        }\n        return records;\n    }\n\n    public static double processImperative(List&lt;Record&gt; records) {\n        double sum = 0.0;\n        int count = 0;\n\n        for (Record r : records) {\n            if (r.value &gt; 500) {\n                sum += r.value;\n                count++;\n            }\n        }\n\n        return count &gt; 0 ? sum / count : 0.0;\n    }\n\n    public static double processFunctional(List&lt;Record&gt; records) {\n        return records.stream()\n            .filter(r -&gt; r.value &gt; 500)\n            .mapToDouble(r -&gt; r.value)\n            .average()\n            .orElse(0.0);\n    }\n\n    public static void main(String[] args) {\n        List&lt;Record&gt; data = generateRecords(1000000);\n\n        double resultImperative = processImperative(data);\n        double resultFunctional = processFunctional(data);\n\n        System.out.println(\"Imperative result: \" + resultImperative);\n        System.out.println(\"Functional result: \" + resultFunctional);\n    }\n}\n</code></pre> <p>Compare imperative vs functional style: <pre><code>codegreen measure java DataProcessor.java --precision high --output processing.json\n</code></pre></p>"},{"location":"examples/java/#matrix-operations","title":"Matrix Operations","text":"<p>CPU-intensive computation example:</p> <pre><code>// MatrixMultiply.java\npublic class MatrixMultiply {\n\n    public static double[][] createMatrix(int size, double value) {\n        double[][] matrix = new double[size][size];\n        for (int i = 0; i &lt; size; i++) {\n            for (int j = 0; j &lt; size; j++) {\n                matrix[i][j] = value;\n            }\n        }\n        return matrix;\n    }\n\n    public static double multiply(double[][] a, double[][] b) {\n        int n = a.length;\n        double[][] c = new double[n][n];\n\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                for (int k = 0; k &lt; n; k++) {\n                    c[i][j] += a[i][k] * b[k][j];\n                }\n            }\n        }\n\n        return c[0][0];\n    }\n\n    public static void main(String[] args) {\n        int size = 500;\n        double[][] a = createMatrix(size, 1.0);\n        double[][] b = createMatrix(size, 2.0);\n\n        double result = multiply(a, b);\n        System.out.println(\"Matrix multiply result: \" + result);\n    }\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure java MatrixMultiply.java --precision high\n</code></pre></p>"},{"location":"examples/java/#parallel-processing-comparison","title":"Parallel Processing Comparison","text":"<p>Compare sequential vs parallel stream processing:</p> <pre><code>// ParallelProcessing.java\nimport java.util.stream.IntStream;\n\npublic class ParallelProcessing {\n\n    public static double computeSequential(int size) {\n        return IntStream.range(0, size)\n            .mapToDouble(i -&gt; Math.sin(i) * Math.cos(i))\n            .sum();\n    }\n\n    public static double computeParallel(int size) {\n        return IntStream.range(0, size)\n            .parallel()\n            .mapToDouble(i -&gt; Math.sin(i) * Math.cos(i))\n            .sum();\n    }\n\n    public static void main(String[] args) {\n        int size = 10000000;\n\n        double seqResult = computeSequential(size);\n        System.out.println(\"Sequential result: \" + seqResult);\n\n        double parResult = computeParallel(size);\n        System.out.println(\"Parallel result: \" + parResult);\n    }\n}\n</code></pre> <p>Measure both approaches: <pre><code>codegreen measure java ParallelProcessing.java --precision high --output parallel_energy.json\n</code></pre></p> <p>Analysis: Parallel processing may use more total energy but complete faster, resulting in better energy efficiency for large workloads.</p>"},{"location":"examples/java/#string-processing","title":"String Processing","text":"<p>Common string operation energy costs:</p> <pre><code>// StringProcessing.java\npublic class StringProcessing {\n\n    public static String concatenateWithPlus(int count) {\n        String result = \"\";\n        for (int i = 0; i &lt; count; i++) {\n            result += \"item\" + i;\n        }\n        return result;\n    }\n\n    public static String concatenateWithBuilder(int count) {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i &lt; count; i++) {\n            builder.append(\"item\").append(i);\n        }\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        int count = 50000;\n\n        String result1 = concatenateWithPlus(count);\n        System.out.println(\"Plus concatenation length: \" + result1.length());\n\n        String result2 = concatenateWithBuilder(count);\n        System.out.println(\"StringBuilder length: \" + result2.length());\n    }\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure java StringProcessing.java --precision high --output string_energy.json\n</code></pre></p> <p>Expected: StringBuilder typically uses 70-90% less energy than string concatenation with <code>+</code>.</p>"},{"location":"examples/java/#recursion-vs-iteration","title":"Recursion vs Iteration","text":"<p>Energy comparison of different implementation styles:</p> <pre><code>// RecursionVsIteration.java\npublic class RecursionVsIteration {\n\n    public static long factorialRecursive(int n) {\n        if (n &lt;= 1) return 1;\n        return n * factorialRecursive(n - 1);\n    }\n\n    public static long factorialIterative(int n) {\n        long result = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int n = 20;\n\n        long recResult = factorialRecursive(n);\n        System.out.println(\"Recursive factorial: \" + recResult);\n\n        long iterResult = factorialIterative(n);\n        System.out.println(\"Iterative factorial: \" + iterResult);\n    }\n}\n</code></pre> <p>Measure: <pre><code>codegreen measure java RecursionVsIteration.java --precision high\n</code></pre></p>"},{"location":"examples/java/#best-practices","title":"Best Practices","text":"<ol> <li>Use Real Computation: Avoid <code>Thread.sleep()</code> - it measures idle power, not code energy</li> <li>Warm-up JVM: Run once before measuring to let JIT compiler optimize</li> <li>Disable JIT for Profiling: Use <code>-Xint</code> flag for consistent measurements</li> <li>Return Results: Prevent dead code elimination by using computation results</li> <li>Multiple Runs: Average across 3-5 runs due to JVM non-determinism</li> </ol>"},{"location":"examples/java/#jvm-options-for-measurement","title":"JVM Options for Measurement","text":""},{"location":"examples/java/#standard-measurement","title":"Standard Measurement","text":"<pre><code>codegreen measure java Program.java --precision high\n</code></pre>"},{"location":"examples/java/#disable-jit-compiler-interpretation-only","title":"Disable JIT Compiler (Interpretation Only)","text":"<pre><code>java -Xint Program.java\ncodegreen measure --instrumented java -Xint Program.class\n</code></pre>"},{"location":"examples/java/#control-heap-size","title":"Control Heap Size","text":"<pre><code>java -Xms512m -Xmx512m Program.java\ncodegreen measure --instrumented java -Xms512m -Xmx512m Program.class\n</code></pre>"},{"location":"examples/java/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/java/#warm-up-before-measurement","title":"Warm-up Before Measurement","text":"<pre><code># Run once to warm up JVM\njava Program.java\n\n# Now measure with optimized code\ncodegreen measure java Program.java --precision high\n</code></pre>"},{"location":"examples/java/#batch-processing","title":"Batch Processing","text":"<pre><code># Measure multiple programs\nfor file in *.java; do\n    codegreen measure java \"$file\" --output \"${file%.java}_energy.json\"\ndone\n</code></pre>"},{"location":"examples/java/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command options</li> <li>Configuration - JVM-specific settings</li> <li>Python Examples - Python energy profiling</li> <li>C/C++ Examples - C/C++ energy profiling</li> </ul>"},{"location":"examples/python/","title":"Python Examples","text":"<p>Practical examples of using CodeGreen with Python programs.</p>"},{"location":"examples/python/#basic-energy-measurement","title":"Basic Energy Measurement","text":"<pre><code># hello_energy.py\ndef greet(name):\n    message = f\"Hello, {name}!\"\n    return message\n\ndef calculate_sum(n):\n    total = sum(range(n))\n    return total\n\ndef main():\n    result = greet(\"CodeGreen\")\n    print(result)\n\n    total = calculate_sum(1000000)\n    print(f\"Sum: {total}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python hello_energy.py --precision high --output results.json\n</code></pre></p> <p>Output: <pre><code>{\n  \"total_energy_joules\": 0.145,\n  \"execution_time_ms\": 12.3,\n  \"functions\": {\n    \"greet\": {\n      \"energy_joules\": 0.001,\n      \"invocations\": 1\n    },\n    \"calculate_sum\": {\n      \"energy_joules\": 0.142,\n      \"invocations\": 1\n    }\n  }\n}\n</code></pre></p>"},{"location":"examples/python/#algorithm-comparison","title":"Algorithm Comparison","text":"<p>Compare energy consumption of different implementations:</p> <pre><code># sorting_comparison.py\nimport random\n\ndef generate_data(size):\n    random.seed(42)\n    return [random.randint(1, 10000) for _ in range(size)]\n\ndef bubble_sort(arr):\n    n = len(arr)\n    arr = arr.copy()\n    for i in range(n):\n        for j in range(n - i - 1):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef quick_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x &lt; pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x &gt; pivot]\n    return quick_sort(left) + middle + quick_sort(right)\n\ndef merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt;= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef main():\n    data = generate_data(5000)\n\n    bubble_result = bubble_sort(data)\n    print(f\"Bubble sort first element: {bubble_result[0]}\")\n\n    quick_result = quick_sort(data)\n    print(f\"Quick sort first element: {quick_result[0]}\")\n\n    merge_result = merge_sort(data)\n    print(f\"Merge sort first element: {merge_result[0]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python sorting_comparison.py --precision high --output sorting.json\n</code></pre></p> <p>Expected results: - Bubble sort: ~12 J (O(n\u00b2)) - Quick sort: ~0.8 J (O(n log n)) - Merge sort: ~1.2 J (O(n log n))</p>"},{"location":"examples/python/#data-processing","title":"Data Processing","text":"<p>Real-world data processing example:</p> <pre><code># data_processing.py\nimport json\n\ndef load_data(size):\n    return [{\"id\": i, \"value\": i * 1.5} for i in range(size)]\n\ndef filter_data(data, threshold):\n    return [item for item in data if item[\"value\"] &gt; threshold]\n\ndef aggregate_data(data):\n    total = sum(item[\"value\"] for item in data)\n    count = len(data)\n    return {\"total\": total, \"average\": total / count if count &gt; 0 else 0}\n\ndef process_pipeline(size):\n    data = load_data(size)\n    filtered = filter_data(data, 500)\n    result = aggregate_data(filtered)\n    return result\n\ndef main():\n    result = process_pipeline(100000)\n    print(f\"Total: {result['total']:.2f}\")\n    print(f\"Average: {result['average']:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python data_processing.py --precision high --json\n</code></pre></p>"},{"location":"examples/python/#machine-learning-example","title":"Machine Learning Example","text":"<p>Energy profiling of ML training:</p> <pre><code># ml_training.py\nimport math\n\ndef sigmoid(x):\n    return 1 / (1 + math.exp(-x))\n\ndef initialize_weights(input_size, output_size):\n    return [[0.1] * output_size for _ in range(input_size)]\n\ndef forward_pass(inputs, weights):\n    return [sum(inputs[i] * weights[i][j] for i in range(len(inputs)))\n            for j in range(len(weights[0]))]\n\ndef train_epoch(data, weights, learning_rate):\n    for inputs, target in data:\n        predictions = forward_pass(inputs, weights)\n        # Simplified gradient update\n        for i in range(len(weights)):\n            for j in range(len(weights[0])):\n                weights[i][j] += learning_rate * 0.01\n    return weights\n\ndef train_model(epochs, data_size):\n    # Generate synthetic data\n    data = [([float(i % 10) / 10 for i in range(5)], 1.0)\n            for _ in range(data_size)]\n\n    weights = initialize_weights(5, 3)\n\n    for epoch in range(epochs):\n        weights = train_epoch(data, weights, 0.01)\n\n    return weights\n\ndef main():\n    final_weights = train_model(epochs=100, data_size=1000)\n    print(f\"Training complete. First weight: {final_weights[0][0]:.4f}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure training energy: <pre><code>codegreen measure python ml_training.py --precision high --output ml_energy.json\n</code></pre></p>"},{"location":"examples/python/#optimization-example","title":"Optimization Example","text":"<p>Before and after optimization:</p> <p>Before (inefficient): <pre><code># string_concat_slow.py\ndef concatenate_slow(n):\n    result = \"\"\n    for i in range(n):\n        result += f\"item{i},\"\n    return result\n\ndef main():\n    result = concatenate_slow(50000)\n    print(f\"Length: {len(result)}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>After (optimized): <pre><code># string_concat_fast.py\ndef concatenate_fast(n):\n    result = []\n    for i in range(n):\n        result.append(f\"item{i},\")\n    return \"\".join(result)\n\ndef main():\n    result = concatenate_fast(50000)\n    print(f\"Length: {len(result)}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>Compare both: <pre><code>codegreen measure python string_concat_slow.py --output slow.json\ncodegreen measure python string_concat_fast.py --output fast.json\n</code></pre></p> <p>Energy savings: Optimized version typically uses 70-85% less energy.</p>"},{"location":"examples/python/#matrix-operations","title":"Matrix Operations","text":"<p>CPU-intensive computation:</p> <pre><code># matrix_multiply.py\ndef create_matrix(rows, cols, value):\n    return [[value] * cols for _ in range(rows)]\n\ndef matrix_multiply(a, b):\n    rows_a, cols_a = len(a), len(a[0])\n    rows_b, cols_b = len(b), len(b[0])\n\n    if cols_a != rows_b:\n        raise ValueError(\"Matrix dimensions incompatible\")\n\n    result = [[0] * cols_b for _ in range(rows_a)]\n\n    for i in range(rows_a):\n        for j in range(cols_b):\n            for k in range(cols_a):\n                result[i][j] += a[i][k] * b[k][j]\n\n    return result\n\ndef main():\n    size = 200\n    a = create_matrix(size, size, 1.5)\n    b = create_matrix(size, size, 2.0)\n\n    result = matrix_multiply(a, b)\n    print(f\"Result[0][0]: {result[0][0]}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python matrix_multiply.py --precision high\n</code></pre></p>"},{"location":"examples/python/#recursive-vs-iterative","title":"Recursive vs Iterative","text":"<p>Energy comparison of implementation styles:</p> <pre><code># recursion_vs_iteration.py\ndef fibonacci_recursive(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n\ndef fibonacci_iterative(n):\n    if n &lt;= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef fibonacci_memoized(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n &lt;= 1:\n        return n\n    memo[n] = fibonacci_memoized(n - 1, memo) + fibonacci_memoized(n - 2, memo)\n    return memo[n]\n\ndef main():\n    n = 30\n\n    result_rec = fibonacci_recursive(n)\n    print(f\"Recursive result: {result_rec}\")\n\n    result_iter = fibonacci_iterative(n)\n    print(f\"Iterative result: {result_iter}\")\n\n    result_memo = fibonacci_memoized(n)\n    print(f\"Memoized result: {result_memo}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python recursion_vs_iteration.py --precision high --output fib_energy.json\n</code></pre></p> <p>Expected: Recursive: ~8 J, Iterative: ~0.001 J, Memoized: ~0.002 J</p>"},{"location":"examples/python/#list-comprehension-vs-loops","title":"List Comprehension vs Loops","text":"<p>Compare different Python idioms:</p> <pre><code># comprehension_vs_loops.py\ndef process_with_loop(data):\n    result = []\n    for item in data:\n        if item % 2 == 0:\n            result.append(item * 2)\n    return result\n\ndef process_with_comprehension(data):\n    return [item * 2 for item in data if item % 2 == 0]\n\ndef process_with_map_filter(data):\n    return list(map(lambda x: x * 2, filter(lambda x: x % 2 == 0, data)))\n\ndef main():\n    data = list(range(1000000))\n\n    result1 = process_with_loop(data)\n    print(f\"Loop result length: {len(result1)}\")\n\n    result2 = process_with_comprehension(data)\n    print(f\"Comprehension result length: {len(result2)}\")\n\n    result3 = process_with_map_filter(data)\n    print(f\"Map/filter result length: {len(result3)}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python comprehension_vs_loops.py --precision high\n</code></pre></p>"},{"location":"examples/python/#numpy-vs-pure-python","title":"NumPy vs Pure Python","text":"<p>Energy comparison with NumPy:</p> <pre><code># numpy_comparison.py\nimport numpy as np\n\ndef sum_pure_python(size):\n    data = list(range(size))\n    result = sum(data)\n    return result\n\ndef sum_numpy(size):\n    data = np.arange(size)\n    result = np.sum(data)\n    return result\n\ndef main():\n    size = 10000000\n\n    python_result = sum_pure_python(size)\n    print(f\"Pure Python result: {python_result}\")\n\n    numpy_result = sum_numpy(size)\n    print(f\"NumPy result: {numpy_result}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Measure: <pre><code>codegreen measure python numpy_comparison.py --precision high\n</code></pre></p> <p>Expected: NumPy typically uses 60-80% less energy for numerical operations.</p>"},{"location":"examples/python/#best-practices","title":"Best Practices","text":"<ol> <li>Use CLI Measurement: CodeGreen instruments code automatically via CLI</li> <li>Avoid I/O During Profiling: File I/O adds measurement noise</li> <li>Return Results: Always use function return values (prevents optimization elimination)</li> <li>Consistent Data: Use same seed for random data when comparing</li> <li>Multiple Runs: Average 3-5 runs for stable results</li> </ol>"},{"location":"examples/python/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/python/#basic-measurement","title":"Basic Measurement","text":"<pre><code>codegreen measure python script.py --precision high\n</code></pre>"},{"location":"examples/python/#save-results-to-json","title":"Save Results to JSON","text":"<pre><code>codegreen measure python script.py --output results.json --json\n</code></pre>"},{"location":"examples/python/#multiple-sensors","title":"Multiple Sensors","text":"<pre><code>codegreen measure python script.py --sensors rapl nvidia\n</code></pre>"},{"location":"examples/python/#low-overhead-monitoring","title":"Low Overhead Monitoring","text":"<pre><code>codegreen measure python script.py --precision low\n</code></pre>"},{"location":"examples/python/#keep-instrumented-file-for-inspection","title":"Keep Instrumented File for Inspection","text":"<pre><code>codegreen measure python script.py --no-cleanup\n</code></pre>"},{"location":"examples/python/#analyzing-results","title":"Analyzing Results","text":"<p>After measurement, analyze the JSON output:</p> <pre><code># analyze_results.py\nimport json\nimport sys\n\ndef analyze_energy_report(filename):\n    with open(filename) as f:\n        data = json.load(f)\n\n    print(f\"Total Energy: {data['total_energy_joules']:.6f} J\")\n    print(f\"Execution Time: {data['execution_time_ms']:.2f} ms\")\n    print(f\"Average Power: {data['average_power_watts']:.3f} W\")\n\n    print(\"\\nFunction Breakdown:\")\n    functions = data.get('functions', {})\n    sorted_funcs = sorted(functions.items(),\n                         key=lambda x: x[1].get('energy_joules', 0),\n                         reverse=True)\n\n    for func_name, metrics in sorted_funcs:\n        energy = metrics.get('energy_joules', 0)\n        invocations = metrics.get('invocations', 0)\n        print(f\"  {func_name}: {energy:.6f} J ({invocations} calls)\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: python analyze_results.py &lt;results.json&gt;\")\n        sys.exit(1)\n\n    analyze_energy_report(sys.argv[1])\n</code></pre> <p>Run: <pre><code>python analyze_results.py results.json\n</code></pre></p>"},{"location":"examples/python/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command options</li> <li>Configuration - Python-specific settings</li> <li>C/C++ Examples - C/C++ energy profiling</li> <li>Java Examples - Java energy profiling</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>CodeGreen uses a JSON configuration file to customize behavior and sensor settings.</p>"},{"location":"getting-started/configuration/#configuration-file-location","title":"Configuration File Location","text":"<ul> <li>Default: <code>~/.config/codegreen/codegreen.json</code></li> <li>Custom: Use <code>--config</code> flag: <code>codegreen --config /path/to/codegreen.json</code></li> </ul>"},{"location":"getting-started/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"enabled\": true,\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1,\n        \"measurement_buffer_size\": 100000,\n        \"auto_restart_failed_providers\": true\n      },\n      \"timing\": {\n        \"precision\": \"high\",\n        \"clock_source\": \"auto\"\n      },\n      \"providers\": {\n        \"intel_rapl\": {\n          \"enabled\": true,\n          \"domains\": [\"package\", \"pp0\", \"dram\"]\n        },\n        \"nvidia_nvml\": {\n          \"enabled\": true\n        },\n        \"amd_rocm\": {\n          \"enabled\": false\n        }\n      }\n    }\n  },\n  \"instrumentation\": {\n    \"checkpoint_strategy\": \"functions\",\n    \"language_specific\": {\n      \"python\": {\n        \"instrument_loops\": false,\n        \"max_depth\": 10\n      }\n    }\n  },\n  \"output\": {\n    \"format\": \"json\",\n    \"verbose\": false\n  }\n}\n</code></pre>"},{"location":"getting-started/configuration/#sensor-configuration","title":"Sensor Configuration","text":""},{"location":"getting-started/configuration/#available-sensors-nemb-providers","title":"Available Sensors (NEMB Providers)","text":"<ul> <li>intel_rapl: Intel/AMD CPU energy monitoring via RAPL interface</li> <li>Domains: package, pp0 (cores), pp1 (GPU), dram, psys (platform)</li> <li>Interface: <code>/sys/class/powercap/intel-rapl:*</code></li> <li> <p>Platforms: Linux (Intel/AMD x86_64)</p> </li> <li> <p>nvidia_nvml: NVIDIA GPU monitoring via NVML</p> </li> <li>Requires: NVIDIA drivers and CUDA toolkit</li> <li> <p>Platforms: Linux, Windows (limited)</p> </li> <li> <p>amd_rocm: AMD GPU via ROCm</p> </li> <li>Requires: ROCm drivers and libraries</li> <li>Platforms: Linux only</li> </ul>"},{"location":"getting-started/configuration/#sensor-settings","title":"Sensor Settings","text":"<pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"providers\": {\n        \"intel_rapl\": {\n          \"enabled\": true,\n          \"domains\": [\"package\", \"pp0\", \"pp1\", \"dram\", \"psys\"]\n        },\n        \"nvidia_nvml\": {\n          \"enabled\": true,\n          \"device_indices\": [0]\n        },\n        \"amd_rocm\": {\n          \"enabled\": false\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Sensor Details: - intel_rapl: Reads <code>/sys/class/powercap/intel-rapl:*</code> (requires permissions) - nvidia_nvml: Uses NVIDIA Management Library (requires CUDA drivers) - amd_rocm: AMD GPU via ROCm (Linux only)</p>"},{"location":"getting-started/configuration/#measurement-settings","title":"Measurement Settings","text":"<pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1,\n        \"measurement_buffer_size\": 100000,\n        \"auto_restart_failed_providers\": true,\n        \"provider_restart_interval\": 5000\n      },\n      \"timing\": {\n        \"precision\": \"high\",\n        \"clock_source\": \"auto\"\n      }\n    }\n  }\n}\n</code></pre> <p>Precision Levels: - <code>low</code>: 100ms sampling, ~0.01% overhead, \u00b110% accuracy - <code>medium</code>: 10ms sampling, ~0.1% overhead, \u00b15% accuracy - <code>high</code>: 1ms sampling, ~1% overhead, \u00b12% accuracy</p> <p>Clock Sources: - <code>auto</code>: Automatically select best available (TSC \u2192 MONOTONIC_RAW \u2192 MONOTONIC) - <code>tsc</code>: Time Stamp Counter (x86/x64 only, highest precision) - <code>monotonic</code>: CLOCK_MONOTONIC (all platforms)</p>"},{"location":"getting-started/configuration/#output-settings","title":"Output Settings","text":"<pre><code>{\n  \"output\": {\n    \"format\": \"json\",       // json, table, csv\n    \"verbose\": false,       // detailed output\n    \"save_to_file\": true,   // save results to file\n    \"output_dir\": \"~/.config/codegreen/results\"\n  }\n}\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>CODEGREEN_CONFIG</code>: Path to configuration file</li> <li><code>CODEGREEN_DEBUG</code>: Enable debug output</li> <li><code>CODEGREEN_LOG_LEVEL</code>: Logging level (DEBUG, INFO, WARNING, ERROR)</li> </ul>"},{"location":"getting-started/configuration/#configuration-commands","title":"Configuration Commands","text":"<pre><code># Show current configuration\ncodegreen config --show\n\n# Edit configuration in default editor\ncodegreen config --edit\n\n# Validate configuration syntax\ncodegreen config --validate\n\n# Reset to default configuration\ncodegreen config --reset\n</code></pre>"},{"location":"getting-started/configuration/#configuration-file-locations-priority-order","title":"Configuration File Locations (Priority Order)","text":"<ol> <li><code>./codegreen.json</code> (Local override in current directory)</li> <li><code>~/.codegreen/codegreen.json</code> (User configuration)</li> <li><code>/etc/codegreen/codegreen.json</code> (System-wide configuration)</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>CodeGreen can be installed via the automated script, built manually from source, or installed for development.</p>"},{"location":"getting-started/installation/#quick-install-recommended","title":"Quick Install (Recommended)","text":"<p>The easiest way to install CodeGreen on Linux/macOS is using the automated script. This handles system dependencies, C++ compilation (NEMB), and Python bindings.</p> <pre><code># 1. Clone the repository\ngit clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\n\n# 2. Run the automated installer\n./install.sh\n</code></pre> <p>What this does: *   Installs required system packages (requires <code>sudo</code>). *   Builds the Native Energy Measurement Backend (NEMB) using CMake. *   Installs the <code>codegreen</code> CLI tool to your system.</p>"},{"location":"getting-started/installation/#post-install-setup","title":"Post-Install Setup","text":"<p>After installation, it is critical to initialize the hardware sensors. This step detects your CPU/GPU capabilities and sets up the necessary permissions (e.g., for reading RAPL energy counters).</p> <pre><code># Initialize sensors (may require sudo for first-time permission setup)\nsudo codegreen init-sensors\n</code></pre>"},{"location":"getting-started/installation/#manual-build","title":"Manual Build","text":"<p>If you prefer to build manually or have specific requirements:</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.8+</li> <li>CMake: 3.16+</li> <li>C++ Compiler: GCC 7+ or Clang (C++17 support)</li> <li>Libraries: <code>libjsoncpp-dev</code>, <code>libcurl4-openssl-dev</code>, <code>libsqlite3-dev</code></li> </ul>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<ol> <li> <p>Clone and Initialize: <pre><code>git clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\ngit submodule update --init --recursive\n</code></pre></p> </li> <li> <p>Build C++ Core: <pre><code>mkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\n</code></pre></p> </li> <li> <p>Install Python Package: <pre><code>cd ..\npip install -e .\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributors or those who want to modify the CodeGreen source code:</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\n</code></pre></p> </li> <li> <p>Install development dependencies: <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Install pre-commit hooks: <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#hardware-requirements","title":"Hardware Requirements","text":"<p>CodeGreen's NEMB (Native Energy Measurement Backend) supports a variety of hardware sensors.</p> Sensor Requirements Linux macOS Windows RAPL Intel/AMD CPU \u2705 \u2705 \u2705 NVML NVIDIA GPU \u2705 \u2705 \u274c ROCm AMD GPU \u2705 \u274c \u274c"},{"location":"getting-started/installation/#hardware-specific-notes","title":"Hardware-Specific Notes","text":"<ul> <li>NVIDIA GPUs: Requires NVIDIA drivers 450.80.02 or later. Optional CUDA Toolkit 11.0+ for advanced features.</li> <li>Intel/AMD CPUs: Requires access to <code>/sys/class/powercap</code> on Linux (handled by <code>codegreen init</code>).</li> </ul>"},{"location":"getting-started/installation/#docker-installation","title":"Docker Installation","text":"<p>For containerized environments, use the official image. Note that you must run with <code>--privileged</code> to allow access to hardware energy counters.</p> <pre><code>docker pull SMART-Dal/codegreen:latest\ndocker run --privileged -it --rm SMART-Dal/codegreen:latest\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Command not found Ensure your installation directory is in your <code>PATH</code>. If you installed via <code>pip --user</code>: <pre><code>export PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre></p> <p>Permission denied (RAPL) If you see errors accessing <code>/sys/class/powercap</code>, run the initialization command: <pre><code>sudo codegreen init-sensors\n</code></pre></p> <p>Missing dependencies Use the built-in diagnostic tool to identify missing libraries or configuration issues: <pre><code>codegreen doctor\n</code></pre></p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter persistent issues:</p> <ol> <li>Check the CLI Reference for correct usage.</li> <li>Run <code>codegreen doctor --verbose</code> for detailed diagnostics.</li> <li>Open an issue on GitHub.</li> </ol>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get up and running with CodeGreen in minutes!</p>"},{"location":"getting-started/quickstart/#1-installation","title":"1. Installation","text":"<p>The fastest way to install CodeGreen and its dependencies is using the installation script:</p> <pre><code># Clone the repository\ngit clone https://github.com/SMART-Dal/codegreen.git\ncd codegreen\n\n# Run installer\n./install.sh\n</code></pre>"},{"location":"getting-started/quickstart/#2-initialize-system","title":"2. Initialize System","text":"<p>CodeGreen needs to detect your hardware sensors (CPU/GPU) and set up permissions.</p> <pre><code># Interactive initialization\ncodegreen init --interactive\n</code></pre>"},{"location":"getting-started/quickstart/#3-verify-setup","title":"3. Verify Setup","text":"<p>Run a quick benchmark to ensure sensors are reading data correctly:</p> <pre><code>codegreen benchmark cpu_stress --duration 5\n</code></pre> <p>Note: If you see \"RAPL energy measurement not available\" error, run with <code>sudo</code> or ensure you completed step 2 (<code>sudo codegreen init-sensors</code>) to set up sensor permissions.</p> <p>If you see energy consumption values (Joules/Watts), you are ready to go!</p>"},{"location":"getting-started/quickstart/#4-measure-your-code","title":"4. Measure Your Code","text":""},{"location":"getting-started/quickstart/#python-scripts","title":"Python Scripts","text":"<pre><code># Analyze and measure a script\ncodegreen measure python my_script.py\n\n# With arguments\ncodegreen measure python train_model.py --epochs 10\n\n# High precision for detailed profiling\ncodegreen measure python optimize_me.py --precision high\n</code></pre>"},{"location":"getting-started/quickstart/#cc-programs","title":"C/C++ Programs","text":"<pre><code># Measure a C++ source file (automatically compiled)\ncodegreen measure cpp main.cpp\n\n# C program\ncodegreen measure c algorithm.c\n</code></pre>"},{"location":"getting-started/quickstart/#what-happens-internally","title":"What Happens Internally","text":"<p>When you run <code>codegreen measure</code>:</p> <ol> <li>Tree-sitter AST Parsing: Identifies function boundaries and instrumentation points</li> <li>Code Instrumentation: Injects lightweight checkpoint calls (<code>name#inv_N_tTHREADID</code>)</li> <li>Background Polling: C++ thread samples hardware sensors at 1ms intervals</li> <li>Execution: Your code runs with ~100-200ns overhead per checkpoint</li> <li>Time-Series Correlation: Binary search + linear interpolation matches checkpoints to energy readings</li> <li>Attribution: Energy difference between enter/exit checkpoints = function energy</li> </ol> <p>Key Insight: Checkpoints are timestamp markers (~100ns), not synchronous hardware reads (~5-20\u03bcs). This achieves 25-100x lower overhead than traditional profiling.</p>"},{"location":"getting-started/quickstart/#5-analyze-results","title":"5. Analyze Results","text":"<p>View the output for: - Total Energy: Consumption in Joules - Average Power: Power draw in Watts - Function Breakdown: Which functions consumed the most energy (with invocation counts) - Recursive Calls: Separate energy attribution for each invocation - Multi-Threading: Per-thread energy tracking - Optimization Tips: Suggestions to improve efficiency</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Complete command reference</li> <li>Configuration - Customize settings</li> <li>CI/CD Integration - Continuous integration workflows</li> </ul>"},{"location":"user-guide/cicd-integration/","title":"CI/CD Integration","text":"<p>Guide to integrating CodeGreen energy measurements into your CI/CD pipelines.</p>"},{"location":"user-guide/cicd-integration/#overview","title":"Overview","text":"<p>CodeGreen can be integrated into continuous integration pipelines to: - Track energy consumption trends over time - Detect energy regressions in pull requests - Enforce energy budgets for critical functions - Generate energy reports in CI artifacts</p>"},{"location":"user-guide/cicd-integration/#github-actions","title":"GitHub Actions","text":""},{"location":"user-guide/cicd-integration/#basic-energy-measurement","title":"Basic Energy Measurement","text":"<pre><code>name: Energy Profiling\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main ]\n\njobs:\n  energy-profile:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install CodeGreen\n        run: |\n          git clone https://github.com/SMART-Dal/codegreen.git /tmp/codegreen\n          cd /tmp/codegreen\n          ./install.sh\n          echo \"/tmp/codegreen/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: Initialize Sensors\n        run: sudo codegreen init-sensors\n\n      - name: Measure Energy\n        run: |\n          codegreen measure python tests/benchmark.py \\\n            --precision high \\\n            --output results/energy.json \\\n            --json\n\n      - name: Upload Energy Report\n        uses: actions/upload-artifact@v3\n        with:\n          name: energy-report\n          path: results/energy.json\n</code></pre>"},{"location":"user-guide/cicd-integration/#energy-regression-detection","title":"Energy Regression Detection","text":"<pre><code>name: Energy Regression Check\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  energy-regression:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install CodeGreen\n        run: |\n          # ... installation steps ...\n\n      - name: Measure PR Energy\n        run: |\n          codegreen measure python src/main.py \\\n            --output pr-energy.json --json\n\n      - name: Checkout Main Branch\n        run: |\n          git fetch origin main\n          git checkout main\n\n      - name: Measure Main Energy\n        run: |\n          codegreen measure python src/main.py \\\n            --output main-energy.json --json\n\n      - name: Compare Energy\n        run: |\n          python3 scripts/compare_energy.py \\\n            main-energy.json pr-energy.json \\\n            --threshold 10\n</code></pre> <p>Energy Comparison Script (<code>scripts/compare_energy.py</code>): <pre><code>import json\nimport sys\n\ndef compare_energy(main_file, pr_file, threshold_percent):\n    with open(main_file) as f:\n        main_data = json.load(f)\n    with open(pr_file) as f:\n        pr_data = json.load(f)\n\n    main_energy = main_data['total_energy_joules']\n    pr_energy = pr_data['total_energy_joules']\n\n    increase = ((pr_energy - main_energy) / main_energy) * 100\n\n    print(f\"Main branch energy: {main_energy:.2f} J\")\n    print(f\"PR energy: {pr_energy:.2f} J\")\n    print(f\"Change: {increase:+.1f}%\")\n\n    if increase &gt; threshold_percent:\n        print(f\"\u274c Energy regression detected: {increase:.1f}% &gt; {threshold_percent}%\")\n        sys.exit(1)\n    else:\n        print(f\"\u2705 Energy within acceptable range\")\n        sys.exit(0)\n\nif __name__ == \"__main__\":\n    compare_energy(sys.argv[1], sys.argv[2], float(sys.argv[3]))\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#matrix-testing-across-hardware","title":"Matrix Testing Across Hardware","text":"<pre><code>name: Multi-Platform Energy Testing\n\non: [push]\n\njobs:\n  energy-test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, ubuntu-22.04]\n        precision: [low, medium, high]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install CodeGreen\n        run: ./scripts/install_codegreen.sh\n\n      - name: Run Energy Tests\n        run: |\n          codegreen measure python tests/suite.py \\\n            --precision ${{ matrix.precision }} \\\n            --output energy-${{ matrix.os }}-${{ matrix.precision }}.json \\\n            --json\n\n      - name: Upload Results\n        uses: actions/upload-artifact@v3\n        with:\n          name: energy-results-${{ matrix.os }}-${{ matrix.precision }}\n          path: energy-*.json\n</code></pre>"},{"location":"user-guide/cicd-integration/#gitlab-ci","title":"GitLab CI","text":""},{"location":"user-guide/cicd-integration/#basic-pipeline","title":"Basic Pipeline","text":"<pre><code># .gitlab-ci.yml\n\nstages:\n  - setup\n  - measure\n  - report\n\ninstall_codegreen:\n  stage: setup\n  script:\n    - git clone https://github.com/SMART-Dal/codegreen.git /tmp/codegreen\n    - cd /tmp/codegreen &amp;&amp; ./install.sh\n  artifacts:\n    paths:\n      - /tmp/codegreen/bin/codegreen\n    expire_in: 1 hour\n\nmeasure_energy:\n  stage: measure\n  dependencies:\n    - install_codegreen\n  script:\n    - export PATH=\"/tmp/codegreen/bin:$PATH\"\n    - sudo codegreen init-sensors\n    - codegreen measure python app/main.py --output energy.json --json\n  artifacts:\n    reports:\n      metrics: energy.json\n    paths:\n      - energy.json\n    expire_in: 30 days\n\ngenerate_report:\n  stage: report\n  dependencies:\n    - measure_energy\n  script:\n    - python3 scripts/generate_energy_report.py energy.json &gt; report.md\n  artifacts:\n    paths:\n      - report.md\n    expire_in: 30 days\n</code></pre>"},{"location":"user-guide/cicd-integration/#merge-request-energy-check","title":"Merge Request Energy Check","text":"<pre><code>energy_mr_check:\n  stage: measure\n  only:\n    - merge_requests\n  script:\n    - export PATH=\"/tmp/codegreen/bin:$PATH\"\n    - sudo codegreen init-sensors\n\n    # Measure MR branch\n    - codegreen measure python app/main.py --output mr_energy.json --json\n\n    # Fetch and measure target branch\n    - git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME\n    - git checkout $CI_MERGE_REQUEST_TARGET_BRANCH_NAME\n    - codegreen measure python app/main.py --output target_energy.json --json\n\n    # Compare\n    - python3 scripts/compare_energy.py target_energy.json mr_energy.json --threshold 15\n  allow_failure: true\n</code></pre>"},{"location":"user-guide/cicd-integration/#jenkins-pipeline","title":"Jenkins Pipeline","text":""},{"location":"user-guide/cicd-integration/#declarative-pipeline","title":"Declarative Pipeline","text":"<pre><code>pipeline {\n    agent any\n\n    stages {\n        stage('Install CodeGreen') {\n            steps {\n                sh '''\n                    git clone https://github.com/SMART-Dal/codegreen.git /tmp/codegreen\n                    cd /tmp/codegreen\n                    ./install.sh\n                '''\n            }\n        }\n\n        stage('Initialize Sensors') {\n            steps {\n                sh 'sudo /tmp/codegreen/bin/codegreen init-sensors'\n            }\n        }\n\n        stage('Energy Measurement') {\n            steps {\n                sh '''\n                    export PATH=\"/tmp/codegreen/bin:$PATH\"\n                    codegreen measure python src/application.py \\\n                        --precision high \\\n                        --output energy-${BUILD_NUMBER}.json \\\n                        --json\n                '''\n            }\n        }\n\n        stage('Archive Results') {\n            steps {\n                archiveArtifacts artifacts: 'energy-*.json', fingerprint: true\n            }\n        }\n\n        stage('Trend Analysis') {\n            steps {\n                script {\n                    def currentEnergy = readJSON file: \"energy-${BUILD_NUMBER}.json\"\n                    echo \"Total Energy: ${currentEnergy.total_energy_joules} J\"\n\n                    // Compare with previous build\n                    if (currentBuild.previousBuild != null) {\n                        def previousEnergy = readJSON file: \"energy-${currentBuild.previousBuild.number}.json\"\n                        def change = ((currentEnergy.total_energy_joules - previousEnergy.total_energy_joules) / previousEnergy.total_energy_joules) * 100\n\n                        if (change &gt; 10) {\n                            unstable(message: \"Energy increased by ${change}%\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    post {\n        always {\n            cleanWs()\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/cicd-integration/#docker-integration","title":"Docker Integration","text":""},{"location":"user-guide/cicd-integration/#dockerfile-for-ci","title":"Dockerfile for CI","text":"<pre><code>FROM ubuntu:22.04\n\n# Install dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    cmake \\\n    pkg-config \\\n    libjsoncpp-dev \\\n    libcurl4-openssl-dev \\\n    libsqlite3-dev \\\n    python3 \\\n    python3-pip \\\n    git\n\n# Install CodeGreen\nRUN git clone https://github.com/SMART-Dal/codegreen.git /opt/codegreen &amp;&amp; \\\n    cd /opt/codegreen &amp;&amp; \\\n    ./install.sh\n\nENV PATH=\"/opt/codegreen/bin:${PATH}\"\n\n# Initialize sensors (requires privileged mode)\n# Note: Run container with --privileged flag\nRUN codegreen doctor\n\nWORKDIR /workspace\n</code></pre>"},{"location":"user-guide/cicd-integration/#docker-compose-for-ci","title":"Docker Compose for CI","text":"<pre><code>version: '3.8'\n\nservices:\n  codegreen-ci:\n    build:\n      context: .\n      dockerfile: Dockerfile.codegreen\n    privileged: true\n    volumes:\n      - ./src:/workspace/src\n      - ./results:/workspace/results\n    command: |\n      bash -c \"\n        sudo codegreen init-sensors &amp;&amp;\n        codegreen measure python /workspace/src/main.py \\\n          --output /workspace/results/energy.json \\\n          --json\n      \"\n</code></pre> <p>Run: <pre><code>docker-compose run codegreen-ci\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#travis-ci","title":"Travis CI","text":"<pre><code># .travis.yml\n\nlanguage: python\npython:\n  - \"3.9\"\n\nbefore_install:\n  - git clone https://github.com/SMART-Dal/codegreen.git /tmp/codegreen\n  - cd /tmp/codegreen &amp;&amp; ./install.sh\n  - export PATH=\"/tmp/codegreen/bin:$PATH\"\n\ninstall:\n  - pip install -r requirements.txt\n\nbefore_script:\n  - sudo codegreen init-sensors\n\nscript:\n  - codegreen measure python tests/benchmark.py --output energy.json --json\n\nafter_success:\n  - python scripts/upload_energy_metrics.py energy.json\n</code></pre>"},{"location":"user-guide/cicd-integration/#circleci","title":"CircleCI","text":"<pre><code># .circleci/config.yml\n\nversion: 2.1\n\njobs:\n  energy-measurement:\n    docker:\n      - image: ubuntu:22.04\n    steps:\n      - checkout\n\n      - run:\n          name: Install CodeGreen\n          command: |\n            apt-get update\n            apt-get install -y git build-essential cmake python3\n            git clone https://github.com/SMART-Dal/codegreen.git /tmp/codegreen\n            cd /tmp/codegreen &amp;&amp; ./install.sh\n            echo 'export PATH=\"/tmp/codegreen/bin:$PATH\"' &gt;&gt; $BASH_ENV\n\n      - run:\n          name: Initialize Sensors\n          command: codegreen init-sensors\n\n      - run:\n          name: Measure Energy\n          command: |\n            codegreen measure python app/main.py \\\n              --output /tmp/energy.json \\\n              --json\n\n      - store_artifacts:\n          path: /tmp/energy.json\n          destination: energy-report\n\nworkflows:\n  version: 2\n  energy-workflow:\n    jobs:\n      - energy-measurement\n</code></pre>"},{"location":"user-guide/cicd-integration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/cicd-integration/#1-sensor-initialization","title":"1. Sensor Initialization","text":"<p>Always initialize sensors before measurements: <pre><code>sudo codegreen init-sensors\n# OR\ncodegreen init --interactive\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#2-consistent-hardware","title":"2. Consistent Hardware","text":"<p>Run energy measurements on consistent hardware: - Use dedicated CI runners with RAPL support - Pin to specific runner tags - Document hardware specifications</p> <pre><code># GitHub Actions\nruns-on: [self-hosted, energy-capable]\n\n# GitLab CI\ntags:\n  - energy-capable\n  - ubuntu\n</code></pre>"},{"location":"user-guide/cicd-integration/#3-baseline-measurements","title":"3. Baseline Measurements","text":"<p>Establish energy baselines: <pre><code># Store baseline\ncodegreen measure python tests/baseline.py --output baseline.json\n\n# Compare against baseline\npython scripts/compare_energy.py baseline.json current.json\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#4-energy-budgets","title":"4. Energy Budgets","text":"<p>Set per-function energy budgets: <pre><code># energy_budget.json\n{\n  \"compute_transform\": {\"max_joules\": 10.0},\n  \"process_data\": {\"max_joules\": 5.0},\n  \"render_output\": {\"max_joules\": 2.0}\n}\n</code></pre></p> <pre><code>codegreen measure python app.py --output results.json\npython scripts/check_budget.py results.json energy_budget.json\n</code></pre>"},{"location":"user-guide/cicd-integration/#5-artifact-management","title":"5. Artifact Management","text":"<p>Archive energy reports for historical tracking: <pre><code># GitHub Actions\n- uses: actions/upload-artifact@v3\n  with:\n    name: energy-report-${{ github.sha }}\n    path: energy.json\n    retention-days: 90\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#troubleshooting-ci","title":"Troubleshooting CI","text":""},{"location":"user-guide/cicd-integration/#permission-denied-rapl","title":"Permission Denied (RAPL)","text":"<p>Problem: CI runner can't access <code>/sys/class/powercap/</code></p> <p>Solution 1 - Persistent Permissions: <pre><code># Add to runner setup script\nsudo chmod -R 644 /sys/class/powercap/intel-rapl:*/energy_uj\n</code></pre></p> <p>Solution 2 - Init Sensors: <pre><code>sudo codegreen init-sensors\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#docker-privileged-mode","title":"Docker Privileged Mode","text":"<p>Problem: Docker container can't access hardware sensors</p> <p>Solution: <pre><code>services:\n  ci:\n    image: ubuntu:22.04\n    privileged: true  # Required for RAPL access\n</code></pre></p>"},{"location":"user-guide/cicd-integration/#inconsistent-results","title":"Inconsistent Results","text":"<p>Problem: Energy measurements vary widely between runs</p> <p>Solutions: 1. Increase measurement duration 2. Use multiple runs and average 3. Run on dedicated hardware 4. Set CPU frequency scaling to performance mode</p> <pre><code># Set performance mode\nsudo cpupower frequency-set --governor performance\n\n# Run multiple times\nfor i in {1..5}; do\n  codegreen measure python app.py --output run-$i.json\ndone\n\n# Average results\npython scripts/average_energy.py run-*.json\n</code></pre>"},{"location":"user-guide/cicd-integration/#example-complete-github-actions-workflow","title":"Example: Complete GitHub Actions Workflow","text":"<pre><code>name: Energy CI/CD\n\non:\n  pull_request:\n    branches: [ main ]\n  push:\n    branches: [ main ]\n\njobs:\n  energy-check:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Install CodeGreen\n        run: |\n          git clone https://github.com/SMART-Dal/codegreen.git /tmp/codegreen\n          cd /tmp/codegreen &amp;&amp; ./install.sh\n          echo \"/tmp/codegreen/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: Initialize Sensors\n        run: sudo codegreen init-sensors\n\n      - name: Install Dependencies\n        run: pip install -r requirements.txt\n\n      - name: Run Energy Measurements\n        run: |\n          mkdir -p results\n          codegreen measure python tests/benchmark.py \\\n            --precision high \\\n            --output results/energy.json \\\n            --json\n\n      - name: Check Energy Budget\n        run: |\n          python scripts/check_budget.py \\\n            results/energy.json \\\n            config/energy_budget.json\n\n      - name: Generate Report\n        run: |\n          python scripts/generate_report.py \\\n            results/energy.json \\\n            &gt; results/report.md\n\n      - name: Comment on PR\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const report = fs.readFileSync('results/report.md', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: report\n            });\n\n      - name: Upload Artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: energy-results\n          path: results/\n</code></pre>"},{"location":"user-guide/cicd-integration/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command reference</li> <li>Configuration Reference - Complete configuration guide</li> <li>Examples - Usage examples</li> </ul>"},{"location":"user-guide/cli-reference/","title":"CLI Reference","text":"<p>Complete reference for CodeGreen command-line interface.</p>"},{"location":"user-guide/cli-reference/#global-options","title":"Global Options","text":"<pre><code>codegreen [OPTIONS] COMMAND [ARGS]...\n</code></pre>"},{"location":"user-guide/cli-reference/#options","title":"Options","text":"<ul> <li><code>--debug</code>: Enable debug output</li> <li><code>--config PATH</code>: Path to configuration file</li> <li><code>--version, -v</code>: Show version and exit</li> <li><code>--log-level [DEBUG|INFO|WARNING|ERROR]</code>: Set logging level</li> <li><code>--help, -h</code>: Show help message</li> </ul>"},{"location":"user-guide/cli-reference/#commands","title":"Commands","text":""},{"location":"user-guide/cli-reference/#measure","title":"<code>measure</code>","text":"<p>Instruments code, executes it, and measures energy consumption using hardware sensors.</p> <pre><code>codegreen measure [OPTIONS] LANGUAGE SCRIPT [ARGS]...\n</code></pre> <p>Options: - <code>-o, --output PATH</code>: Save results to file (JSON format) - <code>-s, --sensors SENSOR</code>: Sensors to use (rapl, nvidia, amd_gpu, amd_cpu) - <code>-p, --precision [low|medium|high]</code>: Measurement precision - <code>-t, --timeout SECONDS</code>: Execution timeout - <code>--verbose</code>: Show detailed output - <code>--json</code>: Output results in JSON format - <code>--no-cleanup</code>: Keep temporary instrumented files - <code>--instrumented</code>: Script is already instrumented (skip instrumentation)</p> <p>Precision Levels:</p> Level Interval Overhead Accuracy Use Case <code>low</code> 100ms ~0.01% \u00b110% Production monitoring <code>medium</code> 10ms ~0.1% \u00b15% Development (default) <code>high</code> 1ms ~1% \u00b12% Detailed profiling <p>Technical Details: - Background thread polls hardware sensors at specified interval - Higher precision = more frequent polling = better correlation accuracy - Checkpoint overhead is constant (~100-200ns), independent of precision - Precision affects time-series granularity, not checkpoint cost</p> <p>Examples: <pre><code># Basic measurement (medium precision by default)\ncodegreen measure python script.py\n\n# High precision with multiple sensors\ncodegreen measure python ml_train.py --precision high --sensors rapl nvidia\n\n# Low overhead for production\ncodegreen measure python server.py --precision low\n\n# C++ program measurement\ncodegreen measure cpp main.cpp\n</code></pre></p>"},{"location":"user-guide/cli-reference/#analyze","title":"<code>analyze</code>","text":"<p>Performs static analysis using Tree-sitter AST parsing to identify instrumentation points.</p> <pre><code>codegreen analyze [OPTIONS] LANGUAGE SCRIPT\n</code></pre> <p>Options: - <code>-o, --output PATH</code>: Save analysis to file - <code>--verbose</code>: Show detailed instrumentation points - <code>--suggestions</code>: Show optimization suggestions (default: true) - <code>--save-instrumented</code>: Save instrumented code to current directory - <code>--output-dir PATH</code>: Directory for instrumented code</p>"},{"location":"user-guide/cli-reference/#init","title":"<code>init</code>","text":"<p>Comprehensive system initialization: detects hardware, configures sensors, sets permissions.</p> <pre><code>codegreen init [OPTIONS]\n</code></pre> <p>Options: - <code>--interactive</code>: Interactive setup with prompts - <code>--auto-detect-only</code>: Auto-detect only, no prompts - <code>--sensors SENSOR</code>: Specify sensors to initialize - <code>--force</code>: Overwrite existing configuration</p>"},{"location":"user-guide/cli-reference/#init-sensors","title":"<code>init-sensors</code>","text":"<p>Initialize and cache sensor configuration for NEMB measurement system. Requires root for permission setup.</p> <pre><code>sudo codegreen init-sensors\n</code></pre> <p>Performs comprehensive initialization including: - Discovers available energy measurement hardware (RAPL, NVML, ROCm) - Validates sensor accessibility and permissions - Sets up <code>/sys/class/powercap</code> read permissions - Caches sensor configuration for fast startup</p> <p>Note: This command must be run before any energy measurements can be performed. Run with <code>sudo</code> to ensure proper sensor permissions are configured.</p>"},{"location":"user-guide/cli-reference/#info","title":"<code>info</code>","text":"<p>Display CodeGreen installation, hardware sensors, and system information.</p> <pre><code>codegreen info [OPTIONS]\n</code></pre> <p>Options: - <code>--verbose</code>: Show detailed information - <code>--json</code>: Output in JSON format</p>"},{"location":"user-guide/cli-reference/#doctor","title":"<code>doctor</code>","text":"<p>Diagnose CodeGreen installation and configuration issues.</p> <pre><code>codegreen doctor [OPTIONS]\n</code></pre> <p>Options: - <code>--verbose</code>: Show detailed diagnostic output - <code>--fix</code>: Attempt to fix issues automatically</p>"},{"location":"user-guide/cli-reference/#benchmark","title":"<code>benchmark</code>","text":"<p>Measure energy consumption using built-in synthetic workloads.</p> <pre><code>codegreen benchmark [OPTIONS] WORKLOAD\n</code></pre> <p>Workloads: cpu_stress, memory_stress, mixed, gpu_compute</p> <p>Options: - <code>--duration SECONDS</code>: Duration of benchmark (default: 10) - <code>--intensity [low|medium|high]</code>: Workload intensity - <code>--output PATH</code>: Save results to file</p> <p>Note: May require <code>sudo</code> if sensor permissions haven't been configured via <code>sudo codegreen init-sensors</code>.</p>"},{"location":"user-guide/cli-reference/#validate","title":"<code>validate</code>","text":"<p>Validate measurement accuracy against native tools. Requires root.</p> <pre><code>codegreen validate [OPTIONS]\n</code></pre> <p>Options: - <code>--quick</code>: Quick validation (30 seconds) - <code>--full</code>: Full validation suite - <code>--tolerance PERCENT</code>: Acceptable error tolerance</p>"},{"location":"user-guide/cli-reference/#config","title":"<code>config</code>","text":"<p>Manage CodeGreen configuration.</p> <pre><code>codegreen config [OPTIONS]\n</code></pre> <p>Options: - <code>--show</code>: Display current configuration - <code>--edit</code>: Open configuration in editor - <code>--reset</code>: Reset to default configuration - <code>--validate</code>: Validate configuration syntax</p>"},{"location":"user-guide/code-analysis/","title":"Code Analysis","text":"<p>Static code analysis and instrumentation inspection with CodeGreen.</p>"},{"location":"user-guide/code-analysis/#overview","title":"Overview","text":"<p>CodeGreen's <code>analyze</code> command performs static analysis of your code using Tree-sitter AST parsing to identify instrumentation points, estimate measurement overhead, and suggest optimizations.</p>"},{"location":"user-guide/code-analysis/#basic-analysis","title":"Basic Analysis","text":"<p>Analyze a Python script:</p> <pre><code>codegreen analyze python myapp.py\n</code></pre> <p>Output: <pre><code>\ud83d\udcca Code Analysis Report\n\nFile: myapp.py\nLanguage: Python\nFunctions detected: 12\nClasses detected: 2\nTotal lines: 245\n\nInstrumentation Points:\n  - Functions: 12\n  - Methods: 8\n  - Loops: 0 (loop instrumentation disabled)\n\nEstimated Overhead:\n  - Checkpoint calls: 40 (20 entry + 20 exit)\n  - Per-checkpoint: ~150 ns\n  - Total overhead: ~6 \u03bcs per execution\n\nComplexity Analysis:\n  - process_data: High complexity (nested loops)\n  - calculate_metrics: Medium complexity\n  - parse_input: Low complexity\n</code></pre></p>"},{"location":"user-guide/code-analysis/#detailed-analysis","title":"Detailed Analysis","text":"<p>Show all instrumentation points:</p> <pre><code>codegreen analyze python myapp.py --verbose\n</code></pre> <p>Output includes: <pre><code>Instrumentation Points:\n\nFunction: process_data (line 45)\n  Entry checkpoint: line 46\n  Exit checkpoints: lines 58, 62\n  Estimated invocations: Unknown\n  Complexity: High (3 nested loops)\n\nFunction: calculate_metrics (line 65)\n  Entry checkpoint: line 66\n  Exit checkpoints: line 78\n  Estimated invocations: Unknown\n  Complexity: Medium (1 loop)\n</code></pre></p>"},{"location":"user-guide/code-analysis/#save-instrumented-code","title":"Save Instrumented Code","text":"<p>Generate and save instrumented version for inspection:</p> <pre><code>codegreen analyze python myapp.py --save-instrumented --output-dir ./instrumented\n</code></pre> <p>Creates <code>./instrumented/myapp_instrumented.py</code> with visible checkpoint calls:</p> <pre><code>import codegreen_runtime\n\ndef process_data(data):\n    codegreen_runtime.checkpoint(\"process_data#entry\")\n    try:\n        result = []\n        for item in data:\n            result.append(item * 2)\n        codegreen_runtime.checkpoint(\"process_data#exit\")\n        return result\n    finally:\n        pass\n</code></pre>"},{"location":"user-guide/code-analysis/#optimization-suggestions","title":"Optimization Suggestions","text":"<p>Get energy optimization recommendations:</p> <pre><code>codegreen analyze python myapp.py --suggestions\n</code></pre> <p>Output: <pre><code>\ud83d\udca1 Optimization Suggestions:\n\n1. Function 'process_large_file' (line 120):\n   - Large data processing detected\n   - Suggestion: Consider chunked processing to reduce peak memory\n   - Potential energy savings: 15-30%\n\n2. Function 'convert_format' (line 85):\n   - String concatenation in loop detected\n   - Suggestion: Use list + join() instead of += for strings\n   - Potential energy savings: 40-70%\n\n3. Function 'recursive_search' (line 200):\n   - Deep recursion detected (max depth unknown)\n   - Suggestion: Consider iterative approach with explicit stack\n   - Potential energy savings: 20-40%\n</code></pre></p>"},{"location":"user-guide/code-analysis/#analysis-output-formats","title":"Analysis Output Formats","text":""},{"location":"user-guide/code-analysis/#json-output","title":"JSON Output","text":"<p>Machine-readable analysis:</p> <pre><code>codegreen analyze python myapp.py --output analysis.json --verbose\n</code></pre> <p>analysis.json: <pre><code>{\n  \"file\": \"myapp.py\",\n  \"language\": \"python\",\n  \"statistics\": {\n    \"total_lines\": 245,\n    \"functions\": 12,\n    \"classes\": 2,\n    \"complexity_score\": 28.5\n  },\n  \"instrumentation_points\": [\n    {\n      \"type\": \"function\",\n      \"name\": \"process_data\",\n      \"line\": 45,\n      \"entry_line\": 46,\n      \"exit_lines\": [58, 62],\n      \"complexity\": \"high\",\n      \"estimated_overhead_ns\": 300\n    }\n  ],\n  \"suggestions\": [\n    {\n      \"function\": \"convert_format\",\n      \"line\": 85,\n      \"issue\": \"String concatenation in loop\",\n      \"recommendation\": \"Use list + join()\",\n      \"potential_savings_percent\": \"40-70\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"user-guide/code-analysis/#language-specific-analysis","title":"Language-Specific Analysis","text":""},{"location":"user-guide/code-analysis/#python","title":"Python","text":"<pre><code>codegreen analyze python app.py --verbose\n</code></pre> <p>Detects: - Function definitions - Class methods - Async functions - Generators - List comprehensions (if enabled) - Lambda functions (if enabled)</p>"},{"location":"user-guide/code-analysis/#cc","title":"C/C++","text":"<pre><code>codegreen analyze cpp program.cpp --verbose\n</code></pre> <p>Detects: - Function definitions - Class methods - Template functions - Inline functions - Constructors/destructors</p>"},{"location":"user-guide/code-analysis/#java","title":"Java","text":"<pre><code>codegreen analyze java App.java --verbose\n</code></pre> <p>Detects: - Method definitions - Static methods - Constructors - Lambda expressions (if enabled) - Anonymous classes</p>"},{"location":"user-guide/code-analysis/#instrumentation-strategies","title":"Instrumentation Strategies","text":"<p>Configure checkpoint placement:</p>"},{"location":"user-guide/code-analysis/#functions-only-default","title":"Functions Only (Default)","text":"<pre><code>codegreen analyze python app.py\n# Instruments function boundaries only\n</code></pre>"},{"location":"user-guide/code-analysis/#include-loops","title":"Include Loops","text":"<pre><code>codegreen analyze python app.py --instrument-loops\n# Also instruments loop blocks\n</code></pre>"},{"location":"user-guide/code-analysis/#minimal-entry-points-only","title":"Minimal (Entry Points Only)","text":"<pre><code>codegreen analyze python app.py --minimal\n# Only instruments main/entry functions\n</code></pre>"},{"location":"user-guide/code-analysis/#complexity-metrics","title":"Complexity Metrics","text":"<p>CodeGreen computes complexity scores based on:</p> Metric Weight Description Lines of code 1x Total function lines Nested loops 3x Each level of nesting Conditional branches 2x if/else/switch statements Function calls 1x External function invocations Recursion 5x Recursive calls detected <p>Complexity categories: - Low (0-10): Simple functions, minimal branching - Medium (11-25): Moderate logic, some loops/conditions - High (26-50): Complex logic, nested structures - Very High (&gt;50): Highly complex, refactoring recommended</p>"},{"location":"user-guide/code-analysis/#integration-with-measurement","title":"Integration with Measurement","text":"<p>Analysis helps optimize measurement workflow:</p> <pre><code># 1. Analyze code first\ncodegreen analyze python app.py --suggestions &gt; analysis.txt\n\n# 2. Review suggestions\n\n# 3. Measure baseline\ncodegreen measure python app.py --output baseline.json\n\n# 4. Apply optimizations\n\n# 5. Measure optimized version\ncodegreen measure python app_optimized.py --output optimized.json\n\n# 6. Compare results\npython compare_energy.py baseline.json optimized.json\n</code></pre>"},{"location":"user-guide/code-analysis/#best-practices","title":"Best Practices","text":"<ol> <li>Analyze Before Measuring: Understand overhead and complexity first</li> <li>Review Instrumented Code: Use <code>--save-instrumented</code> to inspect checkpoint placement</li> <li>Check Suggestions: Review optimization recommendations before implementing</li> <li>Validate Complexity: High-complexity functions may benefit from refactoring</li> <li>Language-Specific: Be aware of language-specific patterns (GIL in Python, JIT in Java)</li> </ol>"},{"location":"user-guide/code-analysis/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete analyze command options</li> <li>Energy Measurement - Measuring energy consumption</li> <li>Examples - Practical examples</li> </ul>"},{"location":"user-guide/configuration-reference/","title":"CodeGreen Configuration Guide","text":"<p>Complete guide to configuring CodeGreen for optimal performance and accuracy.</p>"},{"location":"user-guide/configuration-reference/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Configuration File Locations</li> <li>Configuration Structure</li> <li>NEMB Measurement Settings</li> <li>Instrumentation Options</li> <li>Language-Specific Settings</li> <li>Validation and Testing</li> <li>Migration from Old Configs</li> <li>Troubleshooting</li> </ol>"},{"location":"user-guide/configuration-reference/#configuration-file-locations","title":"Configuration File Locations","text":"<p>CodeGreen searches for configuration files in this priority order:</p> <ol> <li>Local Project Override: <code>./config/codegreen.json</code></li> <li>Current Directory: <code>./codegreen.json</code></li> <li>User Configuration: <code>~/.codegreen/codegreen.json</code></li> <li>System-wide: <code>/etc/codegreen/codegreen.json</code></li> </ol> <p>The first file found is used. All others are ignored.</p>"},{"location":"user-guide/configuration-reference/#recommended-setup","title":"Recommended Setup","text":"<p>Development: <pre><code># Project-specific config\ncp config/codegreen.json ./codegreen.json\n# Edit for your project needs\n</code></pre></p> <p>Personal Use: <pre><code># User-level config\nmkdir -p ~/.codegreen\ncp config/codegreen.json ~/.codegreen/codegreen.json\n</code></pre></p> <p>System-wide (requires sudo): <pre><code># All users on system\nsudo mkdir -p /etc/codegreen\nsudo cp config/codegreen.json /etc/codegreen/\n</code></pre></p>"},{"location":"user-guide/configuration-reference/#configuration-structure","title":"Configuration Structure","text":""},{"location":"user-guide/configuration-reference/#minimal-working-configuration","title":"Minimal Working Configuration","text":"<pre><code>{\n  \"version\": \"0.1.0\",\n  \"measurement\": {\n    \"nemb\": {\n      \"enabled\": true,\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1\n      },\n      \"timing\": {\n        \"precision\": \"high\"\n      },\n      \"providers\": {\n        \"intel_rapl\": { \"enabled\": true }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"user-guide/configuration-reference/#complete-configuration-reference","title":"Complete Configuration Reference","text":"<pre><code>{\n  \"version\": \"0.1.0\",\n\n  \"measurement\": {\n    \"nemb\": {\n      \"enabled\": true,\n\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1,\n        \"measurement_buffer_size\": 100000,\n        \"auto_restart_failed_providers\": true,\n        \"provider_restart_interval\": 5000,\n        \"cross_validation\": true,\n        \"cross_validation_threshold\": 0.05\n      },\n\n      \"timing\": {\n        \"precision\": \"high\",\n        \"clock_source\": \"auto\"\n      },\n\n      \"providers\": {\n        \"intel_rapl\": {\n          \"enabled\": true,\n          \"domains\": [\"package\", \"pp0\", \"dram\"],\n          \"validation_enabled\": true\n        },\n        \"nvidia_nvml\": {\n          \"enabled\": true,\n          \"device_indices\": [0],\n          \"validation_enabled\": true\n        },\n        \"amd_rocm\": {\n          \"enabled\": false\n        }\n      },\n\n      \"accuracy\": {\n        \"target_uncertainty_percent\": 1.0,\n        \"measurement_validation\": true,\n        \"outlier_detection\": true,\n        \"noise_filtering\": \"adaptive\",\n        \"statistical_validation\": true,\n        \"confidence_threshold\": 0.95\n      }\n    }\n  },\n\n  \"instrumentation\": {\n    \"checkpoint_strategy\": \"functions\",\n    \"track_invocations\": true,\n    \"track_threads\": true,\n    \"language_specific\": {\n      \"python\": {\n        \"instrument_loops\": false,\n        \"max_recursion_depth\": 100\n      },\n      \"cpp\": {\n        \"instrument_loops\": false,\n        \"track_templates\": true\n      },\n      \"java\": {\n        \"instrument_loops\": false,\n        \"track_lambdas\": true\n      }\n    }\n  },\n\n  \"paths\": {\n    \"temp_directory\": {\n      \"base\": \"${SYSTEM_TEMP}\",\n      \"prefix\": \"codegreen_\",\n      \"cleanup_on_exit\": true\n    },\n    \"database\": {\n      \"default_path\": \"${USER_HOME}/.codegreen/energy_data.db\"\n    },\n    \"logs\": {\n      \"directory\": \"${USER_HOME}/.codegreen/logs\",\n      \"level\": \"INFO\",\n      \"max_files\": 10,\n      \"max_size_mb\": 50\n    }\n  },\n\n  \"languages\": {\n    \"python\": {\n      \"executable\": \"python3\",\n      \"runtime_module\": \"codegreen_runtime.py\",\n      \"extensions\": [\".py\", \".pyw\", \".pyi\"]\n    },\n    \"c\": {\n      \"executable\": \"gcc\",\n      \"compiler_flags\": [\"-O0\", \"-g\"],\n      \"extensions\": [\".c\", \".h\"]\n    },\n    \"cpp\": {\n      \"executable\": \"g++\",\n      \"compiler_flags\": [\"-O0\", \"-g\", \"-std=c++17\"],\n      \"extensions\": [\".cpp\", \".cxx\", \".cc\", \".hpp\", \".h\"]\n    },\n    \"java\": {\n      \"executable\": \"java\",\n      \"compiler\": \"javac\",\n      \"extensions\": [\".java\"]\n    }\n  },\n\n  \"output\": {\n    \"format\": \"json\",\n    \"verbose\": false\n  },\n\n  \"developer\": {\n    \"debug_mode\": false,\n    \"preserve_temp_files\": false\n  }\n}\n</code></pre>"},{"location":"user-guide/configuration-reference/#nemb-measurement-settings","title":"NEMB Measurement Settings","text":""},{"location":"user-guide/configuration-reference/#coordinator-settings","title":"Coordinator Settings","text":"Setting Default Options Description <code>measurement_interval_ms</code> 1 1-100 Background polling interval (lower = more accurate) <code>measurement_buffer_size</code> 100000 1000-1000000 Circular buffer size for energy readings <code>auto_restart_failed_providers</code> true true/false Automatically restart crashed providers <code>provider_restart_interval</code> 5000 1000-60000 Wait time (ms) before restart <p>Performance vs Accuracy:</p> <pre><code>// High Accuracy (recommended for profiling)\n\"coordinator\": {\n  \"measurement_interval_ms\": 1,\n  \"measurement_buffer_size\": 100000\n}\n\n// Balanced (default)\n\"coordinator\": {\n  \"measurement_interval_ms\": 10,\n  \"measurement_buffer_size\": 10000\n}\n\n// Low Overhead (production monitoring)\n\"coordinator\": {\n  \"measurement_interval_ms\": 100,\n  \"measurement_buffer_size\": 1000\n}\n</code></pre>"},{"location":"user-guide/configuration-reference/#timing-settings","title":"Timing Settings","text":"Setting Default Options Description <code>precision</code> high low/medium/high Measurement precision level <code>clock_source</code> auto auto/tsc/monotonic High-resolution timer source <p>Precision Levels: - <code>high</code>: 1ms sampling, ~1% overhead, \u00b12% accuracy - <code>medium</code>: 10ms sampling, ~0.1% overhead, \u00b15% accuracy - <code>low</code>: 100ms sampling, ~0.01% overhead, \u00b110% accuracy</p> <p>Clock Sources: - <code>auto</code>: Automatically select best (TSC \u2192 MONOTONIC_RAW \u2192 MONOTONIC) - <code>tsc</code>: Time Stamp Counter (x86/x64 only, nanosecond precision) - <code>monotonic</code>: CLOCK_MONOTONIC (all platforms, nanosecond precision)</p>"},{"location":"user-guide/configuration-reference/#provider-settings","title":"Provider Settings","text":"<p>Intel RAPL: <pre><code>\"intel_rapl\": {\n  \"enabled\": true,\n  \"domains\": [\"package\", \"pp0\", \"dram\"],\n  \"validation_enabled\": true\n}\n</code></pre></p> <p>Available domains: - <code>package</code>: Total CPU package energy - <code>pp0</code>: Core energy (all cores) - <code>pp1</code>: Uncore/GPU energy (integrated GPU) - <code>dram</code>: Memory subsystem energy - <code>psys</code>: Platform energy (Skylake+)</p> <p>NVIDIA NVML: <pre><code>\"nvidia_nvml\": {\n  \"enabled\": true,\n  \"device_indices\": [0],\n  \"validation_enabled\": true\n}\n</code></pre></p> <p>AMD ROCm: <pre><code>\"amd_rocm\": {\n  \"enabled\": false\n}\n</code></pre></p>"},{"location":"user-guide/configuration-reference/#instrumentation-options","title":"Instrumentation Options","text":""},{"location":"user-guide/configuration-reference/#checkpoint-strategy","title":"Checkpoint Strategy","text":"<pre><code>\"instrumentation\": {\n  \"checkpoint_strategy\": \"functions\",\n  \"track_invocations\": true,\n  \"track_threads\": true\n}\n</code></pre> <p>Strategies: - <code>minimal</code>: Only entry/exit of main function - <code>functions</code>: All function boundaries (default, recommended) - <code>blocks</code>: Function boundaries + loop blocks - <code>all</code>: Maximum instrumentation (high overhead)</p> <p>Invocation Tracking: - <code>track_invocations: true</code>: Adds <code>#inv_N</code> to checkpoint names for recursive functions - <code>track_threads: true</code>: Adds <code>_tTHREADID</code> for multi-threaded programs</p>"},{"location":"user-guide/configuration-reference/#language-specific-settings","title":"Language-Specific Settings","text":"<p>Python: <pre><code>\"python\": {\n  \"instrument_loops\": false,\n  \"max_recursion_depth\": 100\n}\n</code></pre></p> <p>C/C++: <pre><code>\"cpp\": {\n  \"instrument_loops\": false,\n  \"track_templates\": true\n}\n</code></pre></p> <p>Java: <pre><code>\"java\": {\n  \"instrument_loops\": false,\n  \"track_lambdas\": true\n}\n</code></pre></p>"},{"location":"user-guide/configuration-reference/#language-specific-settings_1","title":"Language-Specific Settings","text":""},{"location":"user-guide/configuration-reference/#compiler-configuration","title":"Compiler Configuration","text":"<p>C Programs: <pre><code>\"c\": {\n  \"executable\": \"gcc\",\n  \"compiler_flags\": [\"-O0\", \"-g\"],\n  \"extensions\": [\".c\", \".h\"]\n}\n</code></pre></p> <p>C++ Programs: <pre><code>\"cpp\": {\n  \"executable\": \"g++\",\n  \"compiler_flags\": [\"-O0\", \"-g\", \"-std=c++17\"],\n  \"extensions\": [\".cpp\", \".cxx\", \".cc\", \".hpp\", \".h\"]\n}\n</code></pre></p> <p>Important: Use <code>-O0</code> (no optimization) for accurate measurements. Optimizations can eliminate code, making measurements unreliable.</p>"},{"location":"user-guide/configuration-reference/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"user-guide/configuration-reference/#validate-configuration","title":"Validate Configuration","text":"<pre><code># Check syntax and values\ncodegreen config --validate --verbose\n\n# Show current active configuration\ncodegreen config --show\n\n# Test with minimal workload\ncodegreen benchmark cpu_stress --duration 5\n</code></pre>"},{"location":"user-guide/configuration-reference/#common-validation-errors","title":"Common Validation Errors","text":"<p>Error: Invalid precision value <pre><code>// \u274c Wrong\n\"precision\": \"maximum\"\n\n// \u2705 Correct\n\"precision\": \"high\"\n</code></pre></p> <p>Error: Provider name mismatch <pre><code>// \u274c Wrong\n\"nvidia_gpu\": { \"enabled\": true }\n\n// \u2705 Correct\n\"nvidia_nvml\": { \"enabled\": true }\n</code></pre></p> <p>Error: Missing required fields <pre><code>// \u274c Incomplete\n\"nemb\": {\n  \"enabled\": true\n}\n\n// \u2705 Complete\n\"nemb\": {\n  \"enabled\": true,\n  \"coordinator\": {\n    \"measurement_interval_ms\": 1\n  }\n}\n</code></pre></p>"},{"location":"user-guide/configuration-reference/#migration-from-old-configs","title":"Migration from Old Configs","text":""},{"location":"user-guide/configuration-reference/#from-pmt-based-config-v00x","title":"From PMT-based Config (v0.0.x)","text":"<p>Old Structure: <pre><code>{\n  \"pmt\": {\n    \"preferred_sensors\": [\"rapl\", \"nvml\"],\n    \"measurement_interval_ms\": 1\n  }\n}\n</code></pre></p> <p>New Structure: <pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1\n      },\n      \"providers\": {\n        \"intel_rapl\": { \"enabled\": true },\n        \"nvidia_nvml\": { \"enabled\": true }\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"user-guide/configuration-reference/#migration-script","title":"Migration Script","text":"<pre><code># Backup old config\ncp config/codegreen.json config/codegreen.json.backup\n\n# Copy new template\ncp config/codegreen.json.template config/codegreen.json\n\n# Edit with your settings\ncodegreen config --edit\n</code></pre>"},{"location":"user-guide/configuration-reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/configuration-reference/#config-not-loading","title":"Config Not Loading","text":"<pre><code># Check which config file is being used\ncodegreen info --verbose\n\n# Output will show:\n# Configuration loaded from: /path/to/codegreen.json\n</code></pre>"},{"location":"user-guide/configuration-reference/#syntax-errors","title":"Syntax Errors","text":"<pre><code># Validate JSON syntax\ncodegreen config --validate\n\n# Use a JSON validator\npython3 -m json.tool config/codegreen.json\n</code></pre>"},{"location":"user-guide/configuration-reference/#permission-issues","title":"Permission Issues","text":"<pre><code># RAPL access requires permissions\nsudo codegreen init-sensors\n\n# Or manual setup\nsudo chmod 644 /sys/class/powercap/intel-rapl:*/energy_uj\n</code></pre>"},{"location":"user-guide/configuration-reference/#performance-issues","title":"Performance Issues","text":"<pre><code># Check measurement overhead\ncodegreen doctor --verbose\n\n# Reduce precision if needed\n{\n  \"timing\": { \"precision\": \"low\" },\n  \"coordinator\": { \"measurement_interval_ms\": 100 }\n}\n</code></pre>"},{"location":"user-guide/configuration-reference/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>CodeGreen supports environment variables in config values:</p> <pre><code>{\n  \"paths\": {\n    \"temp_directory\": {\n      \"base\": \"${SYSTEM_TEMP}\"\n    },\n    \"database\": {\n      \"default_path\": \"${USER_HOME}/.codegreen/energy_data.db\"\n    }\n  }\n}\n</code></pre> <p>Available Variables: - <code>${USER_HOME}</code>: User's home directory - <code>${SYSTEM_TEMP}</code>: System temp directory (/tmp) - <code>${EXECUTABLE_DIR}</code>: CodeGreen installation directory - Any custom environment variable: <code>${MY_VAR}</code></p>"},{"location":"user-guide/configuration-reference/#best-practices","title":"Best Practices","text":"<ol> <li>Start with Defaults: Use the provided <code>config/codegreen.json</code> template</li> <li>Validate Early: Run <code>codegreen config --validate</code> after changes</li> <li>Test Incrementally: Change one setting at a time</li> <li>Monitor Overhead: Use <code>codegreen doctor</code> to check measurement impact</li> <li>Version Control: Commit project-specific configs to git</li> <li>Document Changes: Add comments (strip before using JSON parsers)</li> </ol>"},{"location":"user-guide/configuration-reference/#command-reference","title":"Command Reference","text":"<pre><code># Show current configuration\ncodegreen config --show\n\n# Edit configuration\ncodegreen config --edit\n\n# Validate configuration\ncodegreen config --validate\n\n# Reset to defaults\ncodegreen config --reset\n\n# Show config search path\ncodegreen info --verbose\n</code></pre>"},{"location":"user-guide/configuration-reference/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command-line options</li> <li>Installation - Setup and installation guide</li> <li>Quick Start - Getting started with CodeGreen</li> </ul>"},{"location":"user-guide/energy-measurement/","title":"Energy Measurement Guide","text":"<p>Complete guide to measuring energy consumption with CodeGreen.</p>"},{"location":"user-guide/energy-measurement/#overview","title":"Overview","text":"<p>CodeGreen measures energy consumption at the function level using hardware sensors (Intel RAPL, NVIDIA NVML, AMD ROCm). The measurement system uses a signal-generator architecture that achieves sub-millisecond accuracy with minimal overhead.</p>"},{"location":"user-guide/energy-measurement/#supported-sensors","title":"Supported Sensors","text":""},{"location":"user-guide/energy-measurement/#intelamd-cpus-rapl","title":"Intel/AMD CPUs (RAPL)","text":"<p>Running Average Power Limit provides energy counters for: - Package: Total CPU package energy (cores + uncore + integrated GPU) - PP0 (Power Plane 0): CPU cores only - PP1 (Power Plane 1): Integrated GPU (if present) - DRAM: Memory subsystem - PSYS: Platform energy (Skylake and newer)</p> <p>Requirements: - Intel CPU (Sandy Bridge or newer) or AMD CPU (Ryzen or newer) - Linux kernel with powercap interface - Read access to <code>/sys/class/powercap/intel-rapl:*/energy_uj</code></p> <p>Accuracy: \u00b12% for package measurements</p>"},{"location":"user-guide/energy-measurement/#nvidia-gpus-nvml","title":"NVIDIA GPUs (NVML)","text":"<p>NVIDIA Management Library provides GPU energy consumption.</p> <p>Requirements: - NVIDIA GPU (Kepler or newer recommended) - NVIDIA drivers 450.80.02+ - Optional: CUDA Toolkit 11.0+ for advanced features</p> <p>Accuracy: \u00b15% based on power sensors</p>"},{"location":"user-guide/energy-measurement/#amd-gpus-rocm-smi","title":"AMD GPUs (ROCm SMI)","text":"<p>ROCm System Management Interface for AMD GPU monitoring.</p> <p>Requirements: - AMD GPU (Vega or newer) - ROCm drivers installed - Access to <code>/sys/class/drm/*/device/power*</code></p> <p>Accuracy: \u00b15% for supported GPUs</p>"},{"location":"user-guide/energy-measurement/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/energy-measurement/#signal-generator-architecture","title":"Signal-Generator Architecture","text":"<p>CodeGreen uses a decoupled measurement model:</p> <ol> <li>Checkpoint Marking (Application Thread)</li> <li>When your code calls a function, CodeGreen injects a lightweight checkpoint</li> <li>The checkpoint records a high-precision timestamp (~100-200ns overhead)</li> <li> <p>No blocking I/O or hardware reads during code execution</p> </li> <li> <p>Background Polling (Measurement Thread)</p> </li> <li>Independent C++ thread polls hardware sensors at configurable intervals (1-100ms)</li> <li>Builds a time-series of cumulative energy readings</li> <li> <p>Runs independently without blocking application code</p> </li> <li> <p>Correlation (Post-Execution)</p> </li> <li>After execution, CodeGreen correlates checkpoint timestamps with energy time-series</li> <li>Uses binary search + linear interpolation for sub-millisecond accuracy</li> <li>Calculates energy consumed between function entry and exit</li> </ol>"},{"location":"user-guide/energy-measurement/#mathematical-model","title":"Mathematical Model","text":"<p>Energy at checkpoint time <code>tm</code> is interpolated from sensor readings:</p> <pre><code>E(tm) = E(ti) + (E(ti+1) - E(ti)) \u00d7 ((tm - ti) / (ti+1 - ti))\n</code></pre> <p>Where: - <code>(ti, E(ti))</code> and <code>(ti+1, E(ti+1))</code> are consecutive sensor readings - <code>ti &lt; tm &lt; ti+1</code> (checkpoint falls between readings)</p> <p>This achieves accurate energy attribution even for functions shorter than the polling interval.</p>"},{"location":"user-guide/energy-measurement/#precision-levels","title":"Precision Levels","text":"<p>Configure measurement precision vs overhead tradeoff:</p> Level Polling Interval Overhead Accuracy Use Case low 100ms ~0.01% \u00b110% Production monitoring, long-running services medium 10ms ~0.1% \u00b15% Development, general profiling (default) high 1ms ~1% \u00b12% Detailed profiling, optimization work <p>Set precision: <pre><code>codegreen measure python script.py --precision high\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#measurement-modes","title":"Measurement Modes","text":""},{"location":"user-guide/energy-measurement/#1-function-level-measurement-default","title":"1. Function-Level Measurement (Default)","text":"<p>Automatically instruments all functions:</p> <pre><code>codegreen measure python myapp.py --precision high --output results.json\n</code></pre> <p>Output: <pre><code>{\n  \"total_energy_joules\": 15.43,\n  \"execution_time_ms\": 1250.5,\n  \"average_power_watts\": 12.34,\n  \"functions\": {\n    \"process_data\": {\n      \"energy_joules\": 12.15,\n      \"invocations\": 1,\n      \"average_power_watts\": 12.50\n    },\n    \"parse_input\": {\n      \"energy_joules\": 0.28,\n      \"invocations\": 5,\n      \"average_power_watts\": 9.20\n    }\n  }\n}\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#2-multi-sensor-measurement","title":"2. Multi-Sensor Measurement","text":"<p>Measure CPU and GPU simultaneously:</p> <pre><code>codegreen measure python ml_train.py --sensors rapl nvidia --precision high\n</code></pre> <p>Output includes per-sensor breakdown: <pre><code>{\n  \"sensors\": {\n    \"rapl\": {\n      \"package\": 145.32,\n      \"pp0\": 120.45,\n      \"dram\": 24.87\n    },\n    \"nvidia_gpu_0\": {\n      \"gpu\": 234.56\n    }\n  },\n  \"total_energy_joules\": 379.88\n}\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#3-validation-mode","title":"3. Validation Mode","text":"<p>Compare against native tools (requires root):</p> <pre><code>sudo codegreen validate --duration 30 --tolerance 5\n</code></pre> <p>Runs built-in benchmarks and compares CodeGreen measurements against Linux <code>perf</code> for validation.</p>"},{"location":"user-guide/energy-measurement/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/energy-measurement/#1-sensor-initialization","title":"1. Sensor Initialization","text":"<p>Always initialize sensors before first measurement:</p> <pre><code>sudo codegreen init-sensors\n</code></pre> <p>This sets up permissions and caches sensor configuration. Only needs to be run once per system.</p>"},{"location":"user-guide/energy-measurement/#2-baseline-measurements","title":"2. Baseline Measurements","text":"<p>Establish energy baselines for comparison:</p> <pre><code># Measure baseline\ncodegreen measure python app.py --output baseline.json\n\n# After optimization\ncodegreen measure python app.py --output optimized.json\n\n# Compare\npython -c \"\nimport json\nwith open('baseline.json') as f: baseline = json.load(f)\nwith open('optimized.json') as f: optimized = json.load(f)\nimprovement = (baseline['total_energy_joules'] - optimized['total_energy_joules']) / baseline['total_energy_joules'] * 100\nprint(f'Energy improvement: {improvement:.1f}%')\n\"\n</code></pre>"},{"location":"user-guide/energy-measurement/#3-multiple-runs-for-stability","title":"3. Multiple Runs for Stability","text":"<p>Average across multiple runs:</p> <pre><code>for i in {1..5}; do\n    codegreen measure python app.py --output run$i.json\ndone\n</code></pre> <p>Compute statistics across runs to account for system noise.</p>"},{"location":"user-guide/energy-measurement/#4-minimize-background-load","title":"4. Minimize Background Load","text":"<p>For accurate measurements: - Close unnecessary applications - Disable CPU frequency scaling: <code>sudo cpupower frequency-set --governor performance</code> - Run on consistent hardware (avoid thermal throttling)</p>"},{"location":"user-guide/energy-measurement/#5-warm-up-iterations","title":"5. Warm-up Iterations","text":"<p>For JIT-compiled languages (Java, Python JIT):</p> <pre><code># Warm-up run (discarded)\npython app.py\n\n# Actual measurement\ncodegreen measure python app.py --precision high\n</code></pre> <p>This ensures JIT optimizations are applied before measurement.</p>"},{"location":"user-guide/energy-measurement/#common-measurement-scenarios","title":"Common Measurement Scenarios","text":""},{"location":"user-guide/energy-measurement/#scenario-1-algorithm-comparison","title":"Scenario 1: Algorithm Comparison","text":"<pre><code># algorithms.py\ndef algorithm_a(data):\n    # Implementation A\n    return sorted(data)\n\ndef algorithm_b(data):\n    # Implementation B\n    data_copy = data.copy()\n    data_copy.sort()\n    return data_copy\n\ndef main():\n    data = [random.randint(1, 1000) for _ in range(100000)]\n    result_a = algorithm_a(data)\n    result_b = algorithm_b(data)\n</code></pre> <p>Measure: <pre><code>codegreen measure python algorithms.py --precision high --output algo_energy.json\n</code></pre></p> <p>Analyze per-function energy to determine which algorithm is more energy-efficient.</p>"},{"location":"user-guide/energy-measurement/#scenario-2-optimization-verification","title":"Scenario 2: Optimization Verification","text":"<p>Before optimization: <pre><code>codegreen measure python app_v1.py --output v1_energy.json\n</code></pre></p> <p>After optimization: <pre><code>codegreen measure python app_v2.py --output v2_energy.json\n</code></pre></p> <p>Compare total energy and per-function breakdown.</p>"},{"location":"user-guide/energy-measurement/#scenario-3-gpu-vs-cpu-execution","title":"Scenario 3: GPU vs CPU Execution","text":"<pre><code># CPU version\ncodegreen measure python ml_cpu.py --sensors rapl --output cpu_energy.json\n\n# GPU version\ncodegreen measure python ml_gpu.py --sensors rapl nvidia --output gpu_energy.json\n</code></pre> <p>Compare total energy consumption including data transfer overhead.</p>"},{"location":"user-guide/energy-measurement/#measurement-accuracy","title":"Measurement Accuracy","text":""},{"location":"user-guide/energy-measurement/#validation-results","title":"Validation Results","text":"<p>CodeGreen measurements validated against Linux <code>perf</code>:</p> Workload CodeGreen Linux perf Delta Long-running (800J+) 801.96 J 834.30 J -3.88% Short-running (&lt;5J) 0.23 J 2.40 J -90%* <p>*Short-running delta is intentional - CodeGreen excludes runtime overhead (interpreter startup), isolating algorithm energy.</p>"},{"location":"user-guide/energy-measurement/#accuracy-factors","title":"Accuracy Factors","text":"<p>Hardware Resolution: - RAPL: ~61 \u03bcJ (microjoule) resolution - NVML: GPU-dependent, typically ~1 mW resolution - Update rate: 1-1000 Hz depending on hardware</p> <p>Measurement Uncertainty: - Systematic error: &lt;1% (calibrated against external meters) - Random error: &lt;1% (for workloads &gt;1 second) - Total uncertainty: \u00b12% at 95% confidence (high precision mode)</p>"},{"location":"user-guide/energy-measurement/#known-limitations","title":"Known Limitations","text":"<ol> <li>Short-Duration Functions (&lt;1ms): May have higher relative uncertainty</li> <li>Thermal Throttling: Can affect repeatability if system overheats</li> <li>Idle Power: Baseline platform power (15-30W) included in measurements</li> <li>Multi-Socket Systems: RAPL per-socket, requires aggregation</li> </ol>"},{"location":"user-guide/energy-measurement/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/energy-measurement/#permission-denied-accessing-rapl","title":"\"Permission denied\" accessing RAPL","text":"<p>Solution: <pre><code>sudo codegreen init-sensors\n</code></pre></p> <p>Or manually: <pre><code>sudo chmod 644 /sys/class/powercap/intel-rapl:*/energy_uj\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#inconsistent-measurements-between-runs","title":"Inconsistent measurements between runs","text":"<p>Causes: - Background processes consuming CPU - CPU frequency scaling - Thermal throttling</p> <p>Solutions: <pre><code># Set performance governor\nsudo cpupower frequency-set --governor performance\n\n# Check for throttling\nwatch -n 1 \"grep MHz /proc/cpuinfo\"\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#nvidia-gpu-not-detected","title":"NVIDIA GPU not detected","text":"<p>Check drivers: <pre><code>nvidia-smi\ncodegreen info --verbose\n</code></pre></p> <p>Verify permissions: <pre><code>ls -l /dev/nvidia*\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#energy-values-seem-too-highlow","title":"Energy values seem too high/low","text":"<p>Validate measurement system: <pre><code>sudo codegreen validate --quick\n</code></pre></p> <p>Runs known benchmarks with expected energy values.</p>"},{"location":"user-guide/energy-measurement/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"user-guide/energy-measurement/#custom-sensor-selection","title":"Custom Sensor Selection","text":"<pre><code># CPU only\ncodegreen measure python app.py --sensors rapl\n\n# GPU only\ncodegreen measure python app.py --sensors nvidia\n\n# Both\ncodegreen measure python app.py --sensors rapl nvidia\n</code></pre>"},{"location":"user-guide/energy-measurement/#precision-tuning","title":"Precision Tuning","text":"<p>Edit <code>~/.config/codegreen/codegreen.json</code>:</p> <pre><code>{\n  \"measurement\": {\n    \"nemb\": {\n      \"coordinator\": {\n        \"measurement_interval_ms\": 1,\n        \"measurement_buffer_size\": 100000\n      },\n      \"timing\": {\n        \"precision\": \"high\",\n        \"clock_source\": \"auto\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"user-guide/energy-measurement/#output-formats","title":"Output Formats","text":"<p>JSON (machine-readable): <pre><code>codegreen measure python app.py --output results.json --json\n</code></pre></p> <p>Human-readable summary: <pre><code>codegreen measure python app.py\n</code></pre></p>"},{"location":"user-guide/energy-measurement/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command options</li> <li>Configuration Reference - Advanced configuration</li> <li>Examples - Practical examples</li> <li>CI/CD Integration - Automated measurement</li> </ul>"},{"location":"user-guide/reports/","title":"Reports and Visualization","text":"<p>Understanding and visualizing energy measurement results.</p>"},{"location":"user-guide/reports/#report-formats","title":"Report Formats","text":"<p>CodeGreen generates energy reports in multiple formats for different use cases.</p>"},{"location":"user-guide/reports/#json-format-machine-readable","title":"JSON Format (Machine-Readable)","text":"<p>Complete measurement data for programmatic analysis:</p> <pre><code>codegreen measure python app.py --output results.json --json\n</code></pre> <p>results.json: <pre><code>{\n  \"metadata\": {\n    \"timestamp\": \"2026-01-06T03:30:15.123456\",\n    \"command\": \"codegreen measure python app.py\",\n    \"precision\": \"high\",\n    \"hostname\": \"dev-machine\",\n    \"codegreen_version\": \"0.1.0\"\n  },\n  \"system_info\": {\n    \"cpu\": \"Intel Core i7-9750H\",\n    \"cpu_cores\": 6,\n    \"gpu\": \"NVIDIA GeForce GTX 1660 Ti\",\n    \"os\": \"Linux 5.15.0\"\n  },\n  \"total_energy_joules\": 15.432,\n  \"execution_time_ms\": 1250.5,\n  \"average_power_watts\": 12.34,\n  \"sensors\": {\n    \"rapl\": {\n      \"package\": 12.150,\n      \"pp0\": 10.450,\n      \"dram\": 1.700\n    },\n    \"nvidia_gpu_0\": {\n      \"gpu\": 3.282\n    }\n  },\n  \"functions\": {\n    \"main\": {\n      \"energy_joules\": 15.420,\n      \"invocations\": 1,\n      \"average_power_watts\": 12.33,\n      \"execution_time_ms\": 1250.0\n    },\n    \"process_data\": {\n      \"energy_joules\": 12.150,\n      \"invocations\": 1,\n      \"average_power_watts\": 12.50,\n      \"execution_time_ms\": 972.0\n    },\n    \"parse_input\": {\n      \"energy_joules\": 0.285,\n      \"invocations\": 5,\n      \"average_power_watts\": 9.20,\n      \"execution_time_ms\": 31.0\n    }\n  }\n}\n</code></pre></p>"},{"location":"user-guide/reports/#text-summary-human-readable","title":"Text Summary (Human-Readable)","text":"<p>Quick overview of energy consumption:</p> <pre><code>codegreen measure python app.py\n</code></pre> <p>Output: <pre><code>\ud83d\udd0b Energy Measurement Results\n\nExecution Time: 1.25 seconds\nTotal Energy:   15.43 Joules\nAverage Power:  12.34 Watts\n\nSensor Breakdown:\n  CPU Package:  12.15 J (78.7%)\n  CPU Cores:    10.45 J (67.7%)\n  DRAM:         1.70 J (11.0%)\n  NVIDIA GPU:   3.28 J (21.3%)\n\nTop Energy Consumers:\n  1. process_data     12.15 J  (78.7%)  972 ms\n  2. parse_input       0.29 J  ( 1.8%)   31 ms  (5 calls)\n  3. main             15.42 J  (99.9%) 1250 ms\n</code></pre></p>"},{"location":"user-guide/reports/#csv-format-spreadsheet-compatible","title":"CSV Format (Spreadsheet-Compatible)","text":"<p>For external analysis tools:</p> <pre><code>codegreen measure python app.py --output results.csv --format csv\n</code></pre> <p>results.csv: <pre><code>function_name,energy_joules,invocations,execution_time_ms,average_power_watts\nmain,15.420,1,1250.0,12.33\nprocess_data,12.150,1,972.0,12.50\nparse_input,0.285,5,31.0,9.20\n</code></pre></p>"},{"location":"user-guide/reports/#analyzing-reports","title":"Analyzing Reports","text":""},{"location":"user-guide/reports/#python-analysis-script","title":"Python Analysis Script","text":"<pre><code># analyze_energy.py\nimport json\nimport sys\nfrom collections import defaultdict\n\ndef analyze_report(filename):\n    with open(filename) as f:\n        data = json.load(f)\n\n    total_energy = data['total_energy_joules']\n    functions = data['functions']\n\n    # Sort by energy consumption\n    sorted_funcs = sorted(\n        functions.items(),\n        key=lambda x: x[1]['energy_joules'],\n        reverse=True\n    )\n\n    print(f\"Total Energy: {total_energy:.3f} J\\n\")\n    print(\"Energy Hotspots:\")\n    for i, (name, metrics) in enumerate(sorted_funcs[:5], 1):\n        energy = metrics['energy_joules']\n        percent = (energy / total_energy) * 100\n        calls = metrics.get('invocations', 1)\n        print(f\"  {i}. {name:30s} {energy:8.3f} J ({percent:5.1f}%) - {calls} calls\")\n\n    # Identify high-frequency functions\n    print(\"\\nHigh-Frequency Functions:\")\n    high_freq = [(name, m) for name, m in functions.items()\n                 if m.get('invocations', 1) &gt; 10]\n    for name, metrics in sorted(high_freq, key=lambda x: x[1]['invocations'], reverse=True)[:5]:\n        calls = metrics['invocations']\n        energy_per_call = metrics['energy_joules'] / calls\n        print(f\"  - {name:30s} {calls:6d} calls @ {energy_per_call:.6f} J/call\")\n\nif __name__ == \"__main__\":\n    analyze_report(sys.argv[1])\n</code></pre> <p>Usage: <pre><code>python analyze_energy.py results.json\n</code></pre></p>"},{"location":"user-guide/reports/#comparing-reports","title":"Comparing Reports","text":"<p>Compare before/after optimization:</p> <pre><code># compare_energy.py\nimport json\nimport sys\n\ndef compare_reports(baseline_file, optimized_file):\n    with open(baseline_file) as f:\n        baseline = json.load(f)\n    with open(optimized_file) as f:\n        optimized = json.load(f)\n\n    baseline_energy = baseline['total_energy_joules']\n    optimized_energy = optimized['total_energy_joules']\n\n    improvement = ((baseline_energy - optimized_energy) / baseline_energy) * 100\n\n    print(f\"Baseline Energy:  {baseline_energy:.3f} J\")\n    print(f\"Optimized Energy: {optimized_energy:.3f} J\")\n    print(f\"Improvement:      {improvement:+.1f}%\\n\")\n\n    # Function-level comparison\n    baseline_funcs = baseline['functions']\n    optimized_funcs = optimized['functions']\n\n    print(\"Function-Level Changes:\")\n    for func_name in set(baseline_funcs.keys()) | set(optimized_funcs.keys()):\n        base_e = baseline_funcs.get(func_name, {}).get('energy_joules', 0)\n        opt_e = optimized_funcs.get(func_name, {}).get('energy_joules', 0)\n\n        if base_e &gt; 0:\n            change = ((base_e - opt_e) / base_e) * 100\n            print(f\"  {func_name:30s} {base_e:8.3f} J \u2192 {opt_e:8.3f} J ({change:+6.1f}%)\")\n\nif __name__ == \"__main__\":\n    compare_reports(sys.argv[1], sys.argv[2])\n</code></pre> <p>Usage: <pre><code>python compare_energy.py baseline.json optimized.json\n</code></pre></p>"},{"location":"user-guide/reports/#visualization","title":"Visualization","text":""},{"location":"user-guide/reports/#energy-distribution-pie-chart","title":"Energy Distribution Pie Chart","text":"<pre><code># visualize_energy.py\nimport json\nimport matplotlib.pyplot as plt\n\ndef plot_energy_distribution(filename):\n    with open(filename) as f:\n        data = json.load(f)\n\n    functions = data['functions']\n\n    # Get top 5 functions + \"Others\"\n    sorted_funcs = sorted(\n        functions.items(),\n        key=lambda x: x[1]['energy_joules'],\n        reverse=True\n    )\n\n    labels = []\n    sizes = []\n\n    for name, metrics in sorted_funcs[:5]:\n        labels.append(name)\n        sizes.append(metrics['energy_joules'])\n\n    if len(sorted_funcs) &gt; 5:\n        others_energy = sum(m['energy_joules'] for _, m in sorted_funcs[5:])\n        labels.append('Others')\n        sizes.append(others_energy)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)\n    ax.set_title(f\"Energy Distribution - Total: {data['total_energy_joules']:.2f} J\")\n    plt.savefig('energy_distribution.png', dpi=300, bbox_inches='tight')\n    print(\"Saved: energy_distribution.png\")\n\nif __name__ == \"__main__\":\n    import sys\n    plot_energy_distribution(sys.argv[1])\n</code></pre>"},{"location":"user-guide/reports/#time-series-power-plot","title":"Time-Series Power Plot","text":"<pre><code># plot_power.py\nimport json\nimport matplotlib.pyplot as plt\n\ndef plot_power_over_time(filename):\n    with open(filename) as f:\n        data = json.load(f)\n\n    # Extract power timeline (if available in detailed output)\n    # Simplified example using average power\n    functions = data['functions']\n\n    names = []\n    powers = []\n    times = []\n\n    for name, metrics in functions.items():\n        names.append(name)\n        powers.append(metrics.get('average_power_watts', 0))\n        times.append(metrics.get('execution_time_ms', 0) / 1000)\n\n    fig, ax = plt.subplots(figsize=(12, 6))\n    ax.barh(names, powers, color='steelblue')\n    ax.set_xlabel('Average Power (Watts)')\n    ax.set_title('Function Power Consumption')\n    ax.grid(axis='x', alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig('power_consumption.png', dpi=300, bbox_inches='tight')\n    print(\"Saved: power_consumption.png\")\n\nif __name__ == \"__main__\":\n    import sys\n    plot_power_over_time(sys.argv[1])\n</code></pre>"},{"location":"user-guide/reports/#report-interpretation","title":"Report Interpretation","text":""},{"location":"user-guide/reports/#understanding-metrics","title":"Understanding Metrics","text":"<p>Total Energy (Joules): - Complete energy consumed during execution - Sum of all sensor measurements - Includes CPU, GPU, DRAM</p> <p>Execution Time (ms): - Wall-clock time from start to finish - Includes I/O wait, sleep time</p> <p>Average Power (Watts): - Power = Energy / Time - Indicates intensity of computation - Higher power = more resource-intensive</p> <p>Per-Function Metrics: - Energy consumed while function executes - Includes energy from nested function calls - Recursive/repeated calls tracked separately</p>"},{"location":"user-guide/reports/#common-patterns","title":"Common Patterns","text":"<p>High Energy, Short Time: <pre><code>process_data: 50 J in 500 ms \u2192 100 W average\n</code></pre> - Compute-intensive operation - CPU/GPU running at high utilization - Optimization: Reduce computational complexity</p> <p>Low Energy, Long Time: <pre><code>wait_for_input: 2 J in 5000 ms \u2192 0.4 W average\n</code></pre> - I/O-bound or idle operation - CPU mostly sleeping/waiting - Not a good optimization target</p> <p>Many Small Calls: <pre><code>helper_func: 0.001 J \u00d7 10,000 calls = 10 J total\n</code></pre> - Frequent invocations add up - Optimization: Reduce call frequency or inline</p>"},{"location":"user-guide/reports/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"user-guide/reports/#automated-reporting","title":"Automated Reporting","text":"<pre><code># .github/workflows/energy-report.yml\n- name: Generate Energy Report\n  run: |\n    codegreen measure python app.py --output energy.json --json\n    python scripts/generate_html_report.py energy.json &gt; report.html\n\n- name: Upload Report\n  uses: actions/upload-artifact@v3\n  with:\n    name: energy-report\n    path: report.html\n</code></pre>"},{"location":"user-guide/reports/#energy-regression-detection","title":"Energy Regression Detection","text":"<pre><code># check_regression.py\nimport json\nimport sys\n\ndef check_regression(current_file, baseline_file, threshold=10):\n    with open(current_file) as f:\n        current = json.load(f)\n    with open(baseline_file) as f:\n        baseline = json.load(f)\n\n    current_energy = current['total_energy_joules']\n    baseline_energy = baseline['total_energy_joules']\n\n    increase = ((current_energy - baseline_energy) / baseline_energy) * 100\n\n    if increase &gt; threshold:\n        print(f\"\u274c Energy regression: {increase:.1f}% increase (threshold: {threshold}%)\")\n        sys.exit(1)\n    else:\n        print(f\"\u2705 Energy within limits: {increase:+.1f}% change\")\n        sys.exit(0)\n\nif __name__ == \"__main__\":\n    check_regression(sys.argv[1], sys.argv[2], float(sys.argv[3]))\n</code></pre>"},{"location":"user-guide/reports/#best-practices","title":"Best Practices","text":"<ol> <li>Save All Measurements: Keep historical data for trend analysis</li> <li>Use JSON Format: Machine-readable for automated analysis</li> <li>Compare Baselines: Always measure before/after changes</li> <li>Track Over Time: Monitor energy trends across commits</li> <li>Visualize Results: Charts reveal patterns not obvious in tables</li> <li>Focus on Hotspots: Top 20% of functions often account for 80% of energy</li> </ol>"},{"location":"user-guide/reports/#see-also","title":"See Also","text":"<ul> <li>Energy Measurement - Measurement guide</li> <li>CLI Reference - Output format options</li> <li>CI/CD Integration - Automated reporting</li> <li>Examples - Practical examples</li> </ul>"}]}